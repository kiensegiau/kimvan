const fs = require('fs');
const path = require('path');
const puppeteer = require('puppeteer-core');
const os = require('os');
const axios = require('axios');
const http = require('http');
const https = require('https');
const { uploadToGoogleDrive } = require('./upload-service.js');

// H√†m l√†m s·∫°ch t√™n file ƒë·ªÉ ƒë·∫£m b·∫£o an to√†n cho h·ªá th·ªëng file
function sanitizeFileName(fileName) {
  if (!fileName) return 'unknown_file';
  
  // Lo·∫°i b·ªè c√°c k√Ω t·ª± kh√¥ng h·ª£p l·ªá trong t√™n file
  let sanitized = fileName
    .replace(/[\\/:*?"<>|]/g, '_') // Thay th·∫ø c√°c k√Ω t·ª± kh√¥ng h·ª£p l·ªá b·∫±ng d·∫•u g·∫°ch d∆∞·ªõi
    .replace(/\s+/g, ' ')          // Thay th·∫ø nhi·ªÅu kho·∫£ng tr·∫Øng b·∫±ng m·ªôt kho·∫£ng tr·∫Øng
    .trim();                       // Lo·∫°i b·ªè kho·∫£ng tr·∫Øng ·ªü ƒë·∫ßu v√† cu·ªëi
  
  // Gi·ªõi h·∫°n ƒë·ªô d√†i t√™n file
  if (sanitized.length > 200) {
    const extension = sanitized.lastIndexOf('.');
    if (extension !== -1 && extension > 190) {
      // N·∫øu c√≥ ph·∫ßn m·ªü r·ªông v√† t√™n file qu√° d√†i
      const ext = sanitized.substring(extension);
      sanitized = sanitized.substring(0, 190) + ext;
    } else {
      // N·∫øu kh√¥ng c√≥ ph·∫ßn m·ªü r·ªông ho·∫∑c ph·∫ßn m·ªü r·ªông ng·∫Øn
      sanitized = sanitized.substring(0, 200);
    }
  }
  
  // ƒê·∫£m b·∫£o t√™n file kh√¥ng tr·ªëng
  if (!sanitized) {
    sanitized = 'unnamed_file';
  }
  
  return sanitized;
}

class VideoProcessor {
  constructor(tempDir = 'temp') {
    this.TEMP_DIR = typeof tempDir === 'string' ? tempDir : 'temp';
    this.browser = null;
    this.profilePath = path.join(os.homedir(), 'drive-pdf-watermark-profile');
    this.ensureTempDir();
    this.ensureProfileDir();
    
    // C·∫•u h√¨nh cho download
    this.MAX_RETRIES = 3;
    this.RETRY_DELAY = 2000;
    this.CHUNK_SIZE = 25 * 1024 * 1024; // 25MB m·ªói chunk
    this.CONCURRENT_CHUNKS = 20;
    this.MAX_CHUNK_RETRIES = 5;
    
    // L∆∞u tr·ªØ d·ªØ li·ªáu video hi·ªán t·∫°i
    this.currentFormatData = null;
    this.currentVideoId = null;
  }

  ensureTempDir() {
    if (!fs.existsSync(this.TEMP_DIR)) {
      fs.mkdirSync(this.TEMP_DIR, { recursive: true });
    }
  }

  ensureProfileDir() {
    try {
      if (!fs.existsSync(this.profilePath)) {
        fs.mkdirSync(this.profilePath, { recursive: true });
      }
      console.log(`üîë S·ª≠ d·ª•ng h·ªì s∆° Chrome t·∫°i: ${this.profilePath}`);
    } catch (error) {
      console.error(`‚ùå L·ªói t·∫°o th∆∞ m·ª•c h·ªì s∆° Chrome: ${error.message}`);
    }
  }

  async handlePDFToVideo(fileId, fileName, targetFolderId) {
    const startTime = Date.now();
    let tempFiles = [];

    try {
      console.log(`üé• B·∫Øt ƒë·∫ßu x·ª≠ l√Ω video: ${fileId}, fileName: ${fileName}`);
      const safeFileName = sanitizeFileName(fileName);

      // T·∫°o ƒë∆∞·ªùng d·∫´n t·∫°m v·ªõi timestamp
      const tempPath = path.join(
        this.TEMP_DIR,
        `temp_${Date.now()}_${safeFileName}`
      );
      tempFiles.push(tempPath);

      // T·∫£i video v√†o th∆∞ m·ª•c t·∫°m
      console.log(`üì• B·∫Øt ƒë·∫ßu t·∫£i video v√†o th∆∞ m·ª•c t·∫°m...`);
      await this.downloadVideo(fileId, tempPath);
      console.log(`‚úÖ ƒê√£ t·∫£i xong video v√†o: ${tempPath}`);

      // Upload video l√™n Google Drive
      if (targetFolderId) {
        console.log(`üì§ B·∫Øt ƒë·∫ßu upload video l√™n Google Drive v√†o folder: ${targetFolderId}`);
        const uploadResult = await this.uploadProcessedVideo(tempPath, fileName, targetFolderId);
        
        return {
          success: true,
          filePath: tempPath,
          fileName: fileName,
          fileId: fileId,
          targetFolderId: targetFolderId,
          uploadResult: uploadResult
        };
      }

      return {
        success: true,
        filePath: tempPath,
        fileName: fileName,
        fileId: fileId,
        targetFolderId: targetFolderId
      };

    } catch (error) {
      console.error(`‚ùå L·ªói x·ª≠ l√Ω video: ${error.message}`);
      return {
        success: false,
        error: error.message,
        fileName: fileName,
        fileId: fileId
      };
    } finally {
      // Cleanup temp files n·∫øu c√≥ l·ªói
      if (!tempFiles[0] || !fs.existsSync(tempFiles[0])) {
        for (const tempFile of tempFiles) {
          try {
            if (fs.existsSync(tempFile)) {
              fs.unlinkSync(tempFile);
              console.log(`üßπ ƒê√£ x√≥a file t·∫°m: ${tempFile}`);
            }
          } catch (error) {
            console.warn(`‚ö†Ô∏è Kh√¥ng th·ªÉ x√≥a file t·∫°m: ${tempFile}`);
          }
        }
      }
    }
  }

  async downloadVideo(fileId, outputPath) {
    try {
      this.currentVideoId = fileId;
      
      // Kh·ªüi t·∫°o browser n·∫øu ch∆∞a c√≥
      if (!this.browser) {
        const chromePath = this.getChromePath();
        console.log(`üåê Kh·ªüi ƒë·ªông Chrome: ${chromePath}`);
        
        this.browser = await puppeteer.launch({
          headless: false,
          executablePath: chromePath,
          args: [
            '--start-maximized',
            '--disable-infobars',
            '--no-sandbox',
            '--disable-setuid-sandbox',
            '--disable-dev-shm-usage',
            '--disable-accelerated-2d-canvas',
            '--disable-gpu',
            '--window-size=1920,1080',
            '--hide-scrollbars',
            '--disable-notifications',
            `--user-data-dir=${this.profilePath}`,
            '--enable-extensions',
            '--remote-debugging-port=0',
            '--disable-web-security',
            '--disable-features=IsolateOrigins,site-per-process',
            '--disable-site-isolation-trials',
            '--disable-features=BlockInsecurePrivateNetworkRequests',
            '--disable-features=SameSiteByDefaultCookies,CookiesWithoutSameSiteMustBeSecure'
          ],
          defaultViewport: null,
          ignoreDefaultArgs: ['--enable-automation']
        });
      }

      // L·∫•y URL v√† headers t·ª´ ph∆∞∆°ng th·ª©c m·ªõi
      const result = await this.getVideoUrlAndHeaders(this.browser, fileId);
      
      // Ki·ªÉm tra k·∫øt qu·∫£
      if (!result || !result.url) {
        throw new Error('Kh√¥ng l·∫•y ƒë∆∞·ª£c URL video');
      }
      
      console.log(`üîó ƒê√£ l·∫•y ƒë∆∞·ª£c URL video: ${result.url.substring(0, 100)}...`);
      
      // T·∫£i video b·∫±ng ph∆∞∆°ng th·ª©c chunks
      await this.downloadVideoWithChunks(result.url, outputPath, result.headers || {});
      
      console.log(`‚úÖ ƒê√£ t·∫£i v√† ghi video th√†nh c√¥ng: ${outputPath}`);
      return true;
    } catch (error) {
      console.error(`‚ùå L·ªói t·∫£i video: ${error.message}`);
      throw error;
    }
  }
  
  async uploadProcessedVideo(filePath, fileName, targetFolderId) {
    console.log(`üì§ ƒêang upload video l√™n Google Drive: ${fileName}`);
    
    try {
      // Ki·ªÉm tra file t·ªìn t·∫°i
      if (!fs.existsSync(filePath)) {
        throw new Error(`File kh√¥ng t·ªìn t·∫°i: ${filePath}`);
      }
      
      // Ki·ªÉm tra k√≠ch th∆∞·ªõc file
      const stats = fs.statSync(filePath);
      const fileSizeInBytes = stats.size;
      const fileSizeInMB = fileSizeInBytes / (1024 * 1024);
      console.log(`K√≠ch th∆∞·ªõc file: ${fileSizeInBytes} bytes (${fileSizeInMB.toFixed(2)} MB)`);
      
      // Ph∆∞∆°ng ph√°p 1: S·ª≠ d·ª•ng uploadToGoogleDrive t·ª´ upload-service.js
      try {
        console.log(`üîÑ Upload video s·ª≠ d·ª•ng uploadToGoogleDrive t·ª´ upload-service.js`);
        
        // G·ªçi h√†m uploadToGoogleDrive
        const uploadResult = await uploadToGoogleDrive(
          filePath,
          fileName,
          'video/mp4',
          targetFolderId
        );
        
        console.log(`‚úÖ Upload th√†nh c√¥ng: ${uploadResult.fileName} (ID: ${uploadResult.fileId})`);
        return {
          success: true,
          fileId: uploadResult.fileId,
          fileName: uploadResult.fileName,
          webViewLink: uploadResult.webViewLink,
          webContentLink: uploadResult.webContentLink
        };
      } catch (uploadError) {
        console.error(`‚ùå L·ªói upload qua upload-service: ${uploadError.message}`);
        
        // Ph∆∞∆°ng ph√°p 2: Sao ch√©p file v√†o th∆∞ m·ª•c public
        try {
          console.log(`üîÑ Th·ª≠ ph∆∞∆°ng ph√°p 2: Sao ch√©p file v√†o th∆∞ m·ª•c public`);
          
          // T·∫°o th∆∞ m·ª•c videos trong public n·∫øu ch∆∞a c√≥
          const publicDir = path.join(process.cwd(), 'public');
          const videosDir = path.join(publicDir, 'videos');
          
          if (!fs.existsSync(publicDir)) {
            fs.mkdirSync(publicDir, { recursive: true });
          }
          
          if (!fs.existsSync(videosDir)) {
            fs.mkdirSync(videosDir, { recursive: true });
          }
          
          // T·∫°o t√™n file ƒë√≠ch
          const targetFileName = `video_${Date.now()}_${path.basename(fileName)}`;
          const targetFilePath = path.join(videosDir, targetFileName);
          
          // Sao ch√©p file
          fs.copyFileSync(filePath, targetFilePath);
          
          console.log(`‚úÖ ƒê√£ sao ch√©p video th√†nh c√¥ng v√†o: ${targetFilePath}`);
          
          // T·∫°o URL t∆∞∆°ng ƒë·ªëi
          const relativeUrl = `/videos/${targetFileName}`;
          
          return {
            success: true,
            fileId: `local_${Date.now()}`,
            fileName: targetFileName,
            webViewLink: relativeUrl,
            webContentLink: relativeUrl,
            isLocal: true
          };
        } catch (method2Error) {
          console.error(`‚ùå L·ªói ph∆∞∆°ng ph√°p 2: ${method2Error.message}`);
          throw method2Error;
        }
      }
    } catch (error) {
      console.error(`‚ùå L·ªói upload video: ${error.message}`);
      
      // Tr·∫£ v·ªÅ k·∫øt qu·∫£ kh√¥ng c√≥ upload ƒë·ªÉ √≠t nh·∫•t ng∆∞·ªùi d√πng c√≥ th·ªÉ t·∫£i video v·ªÅ
      console.log(`‚ö†Ô∏è Kh√¥ng th·ªÉ upload video, tr·∫£ v·ªÅ ƒë∆∞·ªùng d·∫´n local: ${filePath}`);
      return {
        success: false,
        error: error.message,
        localFilePath: filePath
      };
    }
  }
  
  async getVideoUrlAndHeaders(browser, fileId) {
    let currentPage = null;
    let retries = 3;
    let savedFormatData = null;

    while (retries > 0) {
      try {
        currentPage = await browser.newPage();

        // L·∫•y cookies t·ª´ page
        const cookies = await currentPage.cookies();
        const cookieString = cookies
          .map((cookie) => `${cookie.name}=${cookie.value}`)
          .join("; ");

        // T·∫°o headers chu·∫©n
        const standardHeaders = {
          Accept: "*/*",
          "Accept-Encoding": "gzip, deflate, br",
          "Accept-Language": "en-US,en;q=0.9",
          Cookie: cookieString,
          Origin: "https://drive.google.com",
          Referer: "https://drive.google.com/",
          "Sec-Fetch-Dest": "video",
          "Sec-Fetch-Mode": "cors",
          "Sec-Fetch-Site": "same-site",
          "User-Agent": await browser.userAgent(),
        };

        // T·∫°o promise ƒë·ªÉ ƒë·ª£i k·∫øt qu·∫£
        const resultPromise = new Promise((resolve, reject) => {
          currentPage.on("response", async (response) => {
            try {
              const url = response.url();
              const headers = response.headers();
              const contentType = headers["content-type"] || "";

              if (contentType.includes("application/json")) {
                let responseData = await response.text();

                // Lo·∫°i b·ªè c√°c k√Ω t·ª± kh√¥ng mong mu·ªën ·ªü ƒë·∫ßu
                if (responseData.startsWith(")]}'")) {
                  responseData = responseData.slice(4);
                }

                try {
                  const jsonData = JSON.parse(responseData);

                  if (jsonData?.mediaStreamingData?.formatStreamingData) {
                    const formatData =
                      jsonData.mediaStreamingData.formatStreamingData;

                    // L∆∞u formatData v√†o bi·∫øn t·∫°m
                    savedFormatData = formatData;

                    const progressiveTranscodes =
                      formatData.progressiveTranscodes || [];

                    // T√¨m URL ch·∫•t l∆∞·ª£ng cao nh·∫•t
                    const fhd = progressiveTranscodes.find(
                      (t) => t.itag === 37
                    );
                    const hd = progressiveTranscodes.find((t) => t.itag === 22);
                    const sd = progressiveTranscodes.find((t) => t.itag === 18);

                    const bestTranscode = fhd || hd || sd;
                    if (bestTranscode) {
                      const result = {
                        url: bestTranscode.url,
                        quality: fhd ? "1080p" : hd ? "720p" : "360p",
                        metadata: bestTranscode,
                        headers: standardHeaders,
                      };

                      resolve(result);
                      return;
                    }
                  }
                } catch (jsonError) {
                  // Th√™m x·ª≠ l√Ω ƒëƒÉng nh·∫≠p khi parse JSON l·ªói
                  const loginCheck = await currentPage.$('input[type="email"]');
                  if (loginCheck) {
                    console.log(`üîí ƒêang ƒë·ª£i ƒëƒÉng nh·∫≠p...`);
                    await currentPage.waitForFunction(
                      () => !document.querySelector('input[type="email"]'),
                      { timeout: 300000 } // 5 ph√∫t
                    );
                    console.log(`‚úÖ ƒê√£ ƒëƒÉng nh·∫≠p xong`);
                    // ƒê·ª£i th√™m 1 ph√∫t sau khi ƒëƒÉng nh·∫≠p
                    console.log(
                      `‚è≥ ƒê·ª£i th√™m 1 ph√∫t ƒë·ªÉ ƒë·∫£m b·∫£o ƒëƒÉng nh·∫≠p ho√†n t·∫•t...`
                    );
                    await new Promise((resolve) => setTimeout(resolve, 100000));

                    // Reload trang sau khi ƒëƒÉng nh·∫≠p
                    await currentPage.reload({
                      waitUntil: ["networkidle0", "domcontentloaded"],
                    });
                    return; // Ti·∫øp t·ª•c v√≤ng l·∫∑p ƒë·ªÉ l·∫•y URL
                  }
                  throw jsonError;
                }
              }
            } catch (error) {
              reject(error);
            }
          });
        });

        // Thi·∫øt l·∫≠p request interception
        await currentPage.setRequestInterception(true);
        currentPage.on("request", (request) => {
          const url = request.url();
          if (url.includes("clients6.google.com")) {
            const headers = request.headers();
            headers["Origin"] = "https://drive.google.com";
            headers["Referer"] = "https://drive.google.com/";
            request.continue({ headers });
          } else {
            request.continue();
          }
        });

        await currentPage.goto(
          `https://drive.google.com/file/d/${fileId}/view`,
          {
            waitUntil: ["networkidle0", "domcontentloaded"],
            timeout: 60000,
          }
        );

        // ƒê·ª£i k·∫øt qu·∫£ v·ªõi timeout
        const result = await Promise.race([
          resultPromise,
          new Promise((_, reject) =>
            setTimeout(
              () => reject(new Error("Timeout waiting for video URL")),
              30000
            )
          ),
        ]);

        if (!result || !result.url) {
          throw new Error("Kh√¥ng t√¨m th·∫•y URL video h·ª£p l·ªá");
        }

        // L∆∞u formatData v√†o this.currentFormatData ch·ªâ khi th√†nh c√¥ng
        if (savedFormatData) {
          this.currentFormatData = savedFormatData;
          console.log(`‚úÖ ƒê√£ l∆∞u formatData th√†nh c√¥ng`);
        }

        await currentPage.close();
        return result;
      } catch (error) {
        console.error(
          `‚ùå L·ªói (c√≤n ${retries} l·∫ßn th·ª≠):`,
          error.message
        );
        retries--;

        if (currentPage) {
          try {
            await currentPage.close();
          } catch (e) {
            console.warn(`‚ö†Ô∏è Kh√¥ng th·ªÉ ƒë√≥ng page:`, e.message);
          }
        }

        if (retries > 0) {
          console.log(`‚è≥ ƒê·ª£i 1s tr∆∞·ªõc khi th·ª≠ l·∫°i...`);
          await new Promise((r) => setTimeout(r, 1000));
        }
      }
    }

    throw new Error("Kh√¥ng t√¨m ƒë∆∞·ª£c URL video sau nhi·ªÅu l·∫ßn th·ª≠");
  }
  
  async downloadVideoWithChunks(videoUrl, outputPath, headers) {
    let downloadedSize = 0;
    const startTime = Date.now();
    let failedChunksCount = 0;
    let progressInterval = null;

    try {
      // ƒê·∫£m b·∫£o th∆∞ m·ª•c t·ªìn t·∫°i
      await fs.promises.mkdir(path.dirname(outputPath), { recursive: true });
      
      // T·∫°o file
      let fh = await fs.promises.open(outputPath, "w");
      await fh.close();
      fh = await fs.promises.open(outputPath, "r+");

      const downloadHeaders = {
        ...headers,
        "User-Agent": headers["User-Agent"] || "Mozilla/5.0",
        Accept: "*/*",
        "Accept-Encoding": "identity",
        Connection: "keep-alive",
        "Sec-Fetch-Dest": "video",
        "Sec-Fetch-Mode": "cors",
        "Sec-Fetch-Site": "same-site",
        Origin: "https://drive.google.com",
        Referer: "https://drive.google.com/",
      };

      // Ki·ªÉm tra URL c√≥ t·ªìn t·∫°i kh√¥ng
      const testResponse = await axios({
        method: "get",
        url: videoUrl,
        headers: {
          ...downloadHeaders,
          Range: "bytes=0-1024",
        },
        timeout: 10000,
        validateStatus: (status) => status === 200 || status === 206,
      });

      // L·∫•y k√≠ch th∆∞·ªõc file
      const headResponse = await axios.head(videoUrl, {
        headers: downloadHeaders,
        timeout: 30000,
        validateStatus: (status) => status === 200 || status === 206,
      });

      const totalSize = parseInt(headResponse.headers["content-length"], 10);
      if (!totalSize) throw new Error("Invalid content length");

      // Chia chunks
      const CHUNK_SIZE = 10 * 1024 * 1024; // 10MB m·ªói chunk
      const chunks = [];
      for (let start = 0; start < totalSize; start += CHUNK_SIZE) {
        const end = Math.min(start + CHUNK_SIZE - 1, totalSize - 1);
        chunks.push({ start, end });
      }

      console.log(`‚öôÔ∏è Chia th√†nh ${chunks.length} chunks, m·ªói chunk ${CHUNK_SIZE / 1024 / 1024}MB`);

      // Progress tracking
      let lastProgress = -1;
      let noProgressCount = 0;

      progressInterval = setInterval(() => {
        const progress = ((downloadedSize / totalSize) * 100).toFixed(1);
        const currentTime = ((Date.now() - startTime) / 1000).toFixed(2);
        const downloadedMB = (downloadedSize / 1024 / 1024).toFixed(2);
        const totalMB = (totalSize / 1024 / 1024).toFixed(2);
        const speed = (downloadedSize / 1024 / 1024 / currentTime).toFixed(2);

        console.log(`‚è¨ ${progress}% (${downloadedMB}/${totalMB}MB) | ${speed}MB/s | ${currentTime}s`);
      }, 2000);

      // Download chunks song song
      for (let i = 0; i < chunks.length; i += 25) {
        const batch = chunks.slice(i, Math.min(i + 25, chunks.length));
        const downloadPromises = batch.map(async (chunk) => {
          let retries = 3;
          while (retries > 0) {
            try {
              const chunkHeaders = {
                ...downloadHeaders,
                Range: `bytes=${chunk.start}-${chunk.end}`,
              };

              const response = await axios({
                method: "get",
                url: videoUrl,
                headers: chunkHeaders,
                responseType: "arraybuffer",
                timeout: 30000,
                maxContentLength: CHUNK_SIZE * 2,
                maxBodyLength: CHUNK_SIZE * 2,
                validateStatus: (status) => status === 200 || status === 206,
              });

              if (!response.data) throw new Error("Empty response");

              const buffer = Buffer.from(response.data);
              await fh.write(buffer, 0, buffer.length, chunk.start);
              downloadedSize += buffer.length;
              break;
            } catch (error) {
              retries--;
              failedChunksCount++;

              if (retries === 0) {
                console.log("‚ö†Ô∏è H·∫øt s·ªë l·∫ßn th·ª≠ l·∫°i cho chunk n√†y");
                break;
              }

              // ƒê·ª£i th·ªùi gian tƒÉng d·∫ßn theo s·ªë l·∫ßn retry
              const waitTime = 5000 * (3 - retries);
              console.log(`‚è≥ ƒê·ª£i ${waitTime / 1000}s tr∆∞·ªõc khi th·ª≠ l·∫°i...`);
              await new Promise((r) => setTimeout(r, waitTime));
            }
          }
        });

        await Promise.all(downloadPromises);
      }

      // D·ªçn d·∫πp
      if (progressInterval) {
        clearInterval(progressInterval);
      }

      await fh.close();
      return true;
    } catch (error) {
      if (progressInterval) {
        clearInterval(progressInterval);
      }
      console.error(`‚ùå L·ªói t·∫£i xu·ªëng: ${error.message}`);
      throw error;
    }
  }

  findBestAdaptiveVideo() {
    try {
      if (!this.currentFormatData?.adaptiveTranscodes) {
        console.log("‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y danh s√°ch video adaptive");
        return null;
      }

      const videos = this.currentFormatData.adaptiveTranscodes.filter(
        (t) => t.itag !== 140 && !t.mimeType?.includes("audio")
      );

      if (videos.length === 0) {
        console.log("‚ùå Kh√¥ng t√¨m th·∫•y video n√†o trong adaptiveTranscodes");
        return null;
      }

      const videoQualities = [
        313, // 4K
        271, // 1440p
        137, // 1080p
        136, // 720p
        135, // 480p
        134, // 360p
        133, // 240p
      ];

      for (const quality of videoQualities) {
        const video = videos.find((t) => t.itag === quality);
        if (video) {
          return video;
        }
      }

      const bestVideo = videos.sort(
        (a, b) => (b.height || 0) - (a.height || 0)
      )[0];

      return bestVideo;
    } catch (error) {
      console.error("‚ùå L·ªói t√¨m video ch·∫•t l∆∞·ª£ng cao:", error.message);
      return null;
    }
  }

  findBestAdaptiveAudio() {
    try {
      if (!this.currentFormatData?.adaptiveTranscodes) {
        console.log("‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y danh s√°ch audio adaptive");
        return null;
      }

      const audio = this.currentFormatData.adaptiveTranscodes.find(
        (t) => t.itag === 140
      );

      if (audio) {
        return audio;
      }

      console.log("‚ùå Kh√¥ng t√¨m th·∫•y audio 140");
      return null;
    } catch (error) {
      console.error("‚ùå L·ªói t√¨m audio:", error.message);
      return null;
    }
  }

  getChromePath() {
    try {
      switch (os.platform()) {
        case 'win32':
          const windowsPaths = [
            'C:\\Program Files\\Google\\Chrome\\Application\\chrome.exe',
            'C:\\Program Files (x86)\\Google\\Chrome\\Application\\chrome.exe',
            'C:\\Users\\Administrator\\AppData\\Local\\Google\\Chrome\\Application\\chrome.exe',
            'C:\\Users\\PC\\AppData\\Local\\Google\\Chrome\\Application\\chrome.exe'
          ];
          
          for (const chromePath of windowsPaths) {
            if (fs.existsSync(chromePath)) {
              console.log(`‚úÖ T√¨m th·∫•y Chrome t·∫°i: ${chromePath}`);
              return chromePath;
            }
          }
          return 'C:\\Program Files\\Google\\Chrome\\Application\\chrome.exe';
          
        case 'darwin':
          return '/Applications/Google Chrome.app/Contents/MacOS/Google Chrome';
        default:
          return '/usr/bin/google-chrome';
      }
    } catch (error) {
      console.error(`‚ùå L·ªói x√°c ƒë·ªãnh ƒë∆∞·ªùng d·∫´n Chrome: ${error.message}`);
      return 'chrome';
    }
  }

  async close() {
    if (this.browser) {
      await this.browser.close();
      this.browser = null;
    }
  }
}

module.exports = VideoProcessor; 