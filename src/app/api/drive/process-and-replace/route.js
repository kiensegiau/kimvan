import { NextResponse } from 'next/server';
import path from 'path';
import fs from 'fs';
import os from 'os';
import { v4 as uuidv4 } from 'uuid';
import { extractDriveFileId } from '@/utils/drive-utils';
import { 
  checkMimeType, 
  processSingleFile, 
  processFolder,
  processAndUploadFile,
  addToProcessingQueue,
  checkFileInfo
} from './lib';

export const maxDuration = 3600; // 60 ph√∫t timeout (thay v√¨ 30 ph√∫t)
export const dynamic = 'force-dynamic';
export const fetchCache = 'force-no-store';

/**
 * API endpoint ƒë·ªÉ x·ª≠ l√Ω v√† thay th·∫ø file t·ª´ Google Drive
 * Endpoint n√†y x·ª≠ l√Ω c·∫£ file ƒë∆°n l·∫ª v√† folder ƒë·ªá quy
 */
export async function POST(request) {
  const startTime = Date.now();
  const tempDir = path.join(os.tmpdir(), uuidv4());
  
  // T·∫°o response stream ƒë·ªÉ g·ª≠i updates
  const encoder = new TextEncoder();
  const customStream = new TransformStream();
  const writer = customStream.writable.getWriter();
  
  // H√†m helper ƒë·ªÉ g·ª≠i updates
  const sendUpdate = async (message) => {
    try {
      await writer.write(encoder.encode(`data: ${JSON.stringify(message)}\n\n`));
    } catch (e) {
      console.error('L·ªói khi g·ª≠i update:', e);
    }
  };

  try {
    console.log('\n=== B·∫ÆT ƒê·∫¶U X·ª¨ L√ù REQUEST PROCESS-AND-REPLACE ===');
    
    // Parse request body
    const requestBody = await request.json();
    
    // Log request body ƒë·ªÉ debug (·∫©n apiKey)
    console.log('üìù Request body:', JSON.stringify({
      ...requestBody,
      apiKey: requestBody.apiKey ? '[HIDDEN]' : undefined
    }, null, 2));
    
    // Tr√≠ch xu·∫•t c√°c th√¥ng s·ªë t·ª´ request
    const {
      fileId,
      url,
      driveLink,
      targetFolderId,
      folderId,
      folderName,
      courseName,
      sheetName,
      apiKey,
      updateSheet = false,
      courseId,
      sheetIndex,
      rowIndex,
      cellIndex,
      sheetId,
      googleSheetName,
      displayText,
      skipProcessing = false
    } = requestBody;

    // Chu·∫©n h√≥a c√°c tham s·ªë
    const finalTargetFolderId = targetFolderId || folderId;
    const finalFolderName = folderName || courseName || sheetName || 'Unknown';

    // Validation c√°c tham s·ªë b·∫Øt bu·ªôc
    if (!fileId && !url && !driveLink) {
      throw new Error('Thi·∫øu fileId, url ho·∫∑c driveLink');
    }

    if (!finalTargetFolderId) {
      throw new Error('Thi·∫øu folder ID ƒë√≠ch (targetFolderId ho·∫∑c folderId)');
    }

    // Validation tham s·ªë c·∫≠p nh·∫≠t sheet
    let canUpdateSheet = false;
    if (updateSheet) {
      console.log(`\nüìã Th√¥ng tin c·∫≠p nh·∫≠t sheet ƒë∆∞·ª£c y√™u c·∫ßu:`);
      console.log(`- courseId: ${courseId || 'kh√¥ng c√≥'}`);
      console.log(`- sheetIndex: ${sheetIndex !== undefined ? sheetIndex : 'kh√¥ng c√≥'}`);
      console.log(`- sheetId: ${sheetId || 'kh√¥ng c√≥'}`);
      console.log(`- googleSheetName: ${googleSheetName || 'kh√¥ng c√≥'}`);
      console.log(`- rowIndex: ${rowIndex !== undefined ? rowIndex : 'kh√¥ng c√≥'}`);
      console.log(`- cellIndex: ${cellIndex !== undefined ? cellIndex : 'kh√¥ng c√≥'}`);
      
      if (courseId) {
        if (sheetIndex === undefined || rowIndex === undefined || cellIndex === undefined) {
          console.warn(`‚ö†Ô∏è Thi·∫øu th√¥ng tin c·∫≠p nh·∫≠t sheet (sheetIndex, rowIndex, cellIndex)`);
          canUpdateSheet = false;
        } else {
          console.log(`‚úÖ ƒê·ªß th√¥ng tin ƒë·ªÉ c·∫≠p nh·∫≠t sheet cho kh√≥a h·ªçc`);
          canUpdateSheet = true;
        }
      } else if (sheetId && googleSheetName) {
        if (rowIndex === undefined || cellIndex === undefined) {
          console.warn(`‚ö†Ô∏è Thi·∫øu th√¥ng tin c·∫≠p nh·∫≠t Google Sheet (rowIndex, cellIndex)`);
          canUpdateSheet = false;
        } else {
          console.log(`‚úÖ ƒê·ªß th√¥ng tin ƒë·ªÉ c·∫≠p nh·∫≠t Google Sheet tr·ª±c ti·∫øp`);
          canUpdateSheet = true;
        }
      } else {
        console.warn(`‚ö†Ô∏è Thi·∫øu th√¥ng tin sheet (courseId ho·∫∑c sheetId + googleSheetName)`);
        canUpdateSheet = false;
      }
    }
    
    // ∆Øu ti√™n s·ª≠ d·ª•ng fileId tr·ª±c ti·∫øp n·∫øu c√≥
    let finalFileId = fileId;
    
    // N·∫øu kh√¥ng c√≥ fileId tr·ª±c ti·∫øp, tr√≠ch xu·∫•t t·ª´ URL
    if (!finalFileId) {
      const urlToExtract = url || driveLink;
      if (urlToExtract) {
        try {
          // X·ª≠ l√Ω URL t·ª´ Google Sheets (c√≥ d·∫°ng https://www.google.com/url?q=...)
          if (urlToExtract.includes('google.com/url?q=')) {
            // Tr√≠ch xu·∫•t ph·∫ßn URL ƒë∆∞·ª£c m√£ h√≥a
            const match = urlToExtract.match(/[?&]q=([^&]+)/);
            if (match && match[1]) {
              // Gi·∫£i m√£ URL
              const decodedUrl = decodeURIComponent(match[1]);
              console.log(`URL sau khi decode: ${decodedUrl}`);
              
              // Tr√≠ch xu·∫•t ID t·ª´ URL ƒë√£ gi·∫£i m√£
              const extracted = extractDriveFileId(decodedUrl);
              if (extracted && extracted.fileId) {
                finalFileId = extracted.fileId;
                console.log(`ƒê√£ tr√≠ch xu·∫•t file ID t·ª´ URL ƒë√£ gi·∫£i m√£: ${finalFileId}`);
              }
            }
          } else {
            // X·ª≠ l√Ω URL th√¥ng th∆∞·ªùng
            const extracted = extractDriveFileId(urlToExtract);
            if (extracted && extracted.fileId) {
              finalFileId = extracted.fileId;
              console.log(`ƒê√£ tr√≠ch xu·∫•t file ID t·ª´ URL: ${finalFileId}`);
            }
          }
        } catch (error) {
          console.error(`L·ªói khi tr√≠ch xu·∫•t file ID t·ª´ URL: ${error.message}`);
        }
      }
    }
    
    if (!finalFileId) {
      throw new Error('Kh√¥ng th·ªÉ l·∫•y ƒë∆∞·ª£c file ID t·ª´ URL');
    }

    // Ki·ªÉm tra lo·∫°i file
    console.log('üîç Ki·ªÉm tra lo·∫°i file...');
    const mimeTypeResult = await checkMimeType(finalFileId);

    // L·∫•y th√™m th√¥ng tin file chi ti·∫øt ƒë·ªÉ l·∫•y t√™n file ch√≠nh x√°c
    let originalFileName = null;
    try {
      const fileInfoResult = await checkFileInfo(finalFileId);
      if (fileInfoResult.success) {
        originalFileName = fileInfoResult.fileName || fileInfoResult.fileInfo?.name;
        console.log(`T√™n file g·ªëc t·ª´ Drive API (chi ti·∫øt): ${originalFileName || 'Kh√¥ng c√≥'}`);
      }
    } catch (fileInfoError) {
      console.error('L·ªói khi l·∫•y th√¥ng tin file chi ti·∫øt:', fileInfoError);
    }
    
    // N·∫øu ch∆∞a c√≥ t√™n file t·ª´ th√¥ng tin chi ti·∫øt, s·ª≠ d·ª•ng k·∫øt qu·∫£ t·ª´ checkMimeType
    if (!originalFileName && mimeTypeResult.success) {
      originalFileName = mimeTypeResult.fileName;
      console.log(`T√™n file g·ªëc t·ª´ Drive API (MIME): ${originalFileName || 'Kh√¥ng c√≥'}`);
    }

    // X·ª≠ l√Ω k·∫øt qu·∫£ ki·ªÉm tra MIME type
    if (!mimeTypeResult.success) {
      console.log(`‚ö†Ô∏è L·ªói khi ki·ªÉm tra MIME type: ${mimeTypeResult.error}`);
      
      // Chuy·ªÉn th·∫≥ng sang x·ª≠ l√Ω b·∫±ng Chrome
      console.log('üåê Chuy·ªÉn sang s·ª≠ d·ª•ng Chrome ƒë·ªÉ t·∫£i v√† x·ª≠ l√Ω file...');
      
      // X√°c ƒë·ªãnh lo·∫°i l·ªói ƒë·ªÉ ghi log
      const errorType = mimeTypeResult.statusCode === 403 ? '403' : (mimeTypeResult.statusCode || 'unknown');
      console.log(`‚ö†Ô∏è Lo·∫°i l·ªói: ${errorType}`);
      
      // Th√™m v√†o h√†ng ƒë·ª£i x·ª≠ l√Ω Chrome
      const chromeResult = await addToProcessingQueue({
        fileId: finalFileId,
        fileName: originalFileName || displayText || `file_${finalFileId}`,
        driveLink,
        targetFolderId: finalTargetFolderId,
        targetFolderName: finalFolderName,
        errorType: errorType.toString(),
        updateSheet,
        courseId: null,
        sheetIndex,
        rowIndex,
        cellIndex,
        sheetId,
        googleSheetName,
        displayText: originalFileName || displayText,
        request,
        tempDir
      });
      
      if (chromeResult) {
        return NextResponse.json({
          ...chromeResult,
          processingMode: `chrome_${errorType}`
        });
      }
      
      return NextResponse.json({ 
        status: 'queued',
        message: 'File ƒë√£ ƒë∆∞·ª£c th√™m v√†o h√†ng ƒë·ª£i x·ª≠ l√Ω Chrome'
      });
    }

    // N·∫øu l√† th∆∞ m·ª•c, x·ª≠ l√Ω ƒë·ªá quy
    if (mimeTypeResult.isFolder) {
      console.log('\nüìÇ PH√ÅT HI·ªÜN TH∆Ø M·ª§C - B·∫ÆT ƒê·∫¶U X·ª¨ L√ù ƒê·ªÜ QUY');
      
      // Import c√°c h√†m c·∫ßn thi·∫øt tr∆∞·ªõc khi s·ª≠ d·ª•ng
      let getTokenByType, checkAllTokens;
      
      // Ki·ªÉm tra c√°c token tr∆∞·ªõc khi th·ª±c hi·ªán x·ª≠ l√Ω folder
      try {
        const utils = await import('./lib/utils.js');
        getTokenByType = utils.getTokenByType;
        checkAllTokens = utils.checkAllTokens;
        
        const tokenStatus = await checkAllTokens();
        
        if (!tokenStatus.download || !tokenStatus.upload) {
          throw new Error('Token Google Drive kh√¥ng h·ª£p l·ªá ho·∫∑c h·∫øt h·∫°n. Vui l√≤ng c·∫≠p nh·∫≠t token.');
        }
        
        console.log('‚úÖ C√°c token Google Drive h·ª£p l·ªá, ti·∫øp t·ª•c x·ª≠ l√Ω folder');
      } catch (tokenError) {
        console.error(`‚ùå L·ªói ki·ªÉm tra token: ${tokenError.message}`);
        throw new Error(`Kh√¥ng th·ªÉ x·ª≠ l√Ω folder: ${tokenError.message}`);
      }
      
      // T·∫°o c√°c options cho vi·ªác x·ª≠ l√Ω th∆∞ m·ª•c
      const folderOptions = {
        targetFolderId: finalTargetFolderId,
        apiKey,
        updateSheet,
        courseId,
        sheetIndex,
        rowIndex,
        cellIndex,
        sheetId,
        googleSheetName,
        displayText,
        request,
        originalFolderLink: driveLink,
        sheetFolderName: finalFolderName
      };
      
      try {
        // Import c·∫ßn thi·∫øt
        const { google } = require('googleapis');
        const path = require('path');
        const fs = require('fs');
        
        // ƒê·∫£m b·∫£o getTokenByType ƒë√£ ƒë∆∞·ª£c ƒë·ªãnh nghƒ©a
        if (!getTokenByType) {
          console.log('ƒêang import l·∫°i utils v√¨ getTokenByType ch∆∞a ƒë∆∞·ª£c ƒë·ªãnh nghƒ©a');
          const utils = await import('./lib/utils.js');
          getTokenByType = utils.getTokenByType;
        }
        
        // L·∫•y token upload v√† download
        const uploadToken = getTokenByType('upload');
        const downloadToken = getTokenByType('download');

        if (!uploadToken || !downloadToken) {
          throw new Error('Kh√¥ng th·ªÉ l·∫•y token Google Drive, vui l√≤ng ki·ªÉm tra l·∫°i');
        }
        
        // Thi·∫øt l·∫≠p OAuth clients
        const uploadOAuth2Client = new google.auth.OAuth2(
          process.env.GOOGLE_CLIENT_ID,
          process.env.GOOGLE_CLIENT_SECRET,
          process.env.GOOGLE_REDIRECT_URI
        );
        uploadOAuth2Client.setCredentials(uploadToken);
        
        const downloadOAuth2Client = new google.auth.OAuth2(
          process.env.GOOGLE_CLIENT_ID,
          process.env.GOOGLE_CLIENT_SECRET,
          process.env.GOOGLE_REDIRECT_URI
        );
        downloadOAuth2Client.setCredentials(downloadToken);
        
        // Kh·ªüi t·∫°o Drive clients
        const uploadDrive = google.drive({ version: 'v3', auth: uploadOAuth2Client });
        const downloadDrive = google.drive({ version: 'v3', auth: downloadOAuth2Client });
        
        // L·∫•y th√¥ng tin v·ªÅ th∆∞ m·ª•c ngu·ªìn
        console.log(`üìÇ L·∫•y th√¥ng tin th∆∞ m·ª•c ngu·ªìn: ${finalFileId}`);
        const folder = await downloadDrive.files.get({
          fileId: finalFileId,
          fields: 'name,parents,mimeType',
          supportsAllDrives: true
        });
        
        console.log(`üìÇ Th√¥ng tin th∆∞ m·ª•c ngu·ªìn: ${folder.data.name} (${folder.data.mimeType})`);
        
        // T√¨m ho·∫∑c t·∫°o th∆∞ m·ª•c cha ƒë√≠ch
        console.log(`üìÇ T√¨m ho·∫∑c t·∫°o th∆∞ m·ª•c ƒë√≠ch trong: ${finalTargetFolderId}`);
        
        // Ki·ªÉm tra xem th∆∞ m·ª•c ƒë√£ t·ªìn t·∫°i trong ƒë√≠ch ch∆∞a
        const escapedFolderName = folder.data.name.replace(/'/g, "\\'");
        const existingFolders = await uploadDrive.files.list({
          q: `'${finalTargetFolderId}' in parents and name = '${escapedFolderName}' and mimeType = 'application/vnd.google-apps.folder' and trashed = false`,
          fields: 'files(id, name, webViewLink)',
          supportsAllDrives: true
        });
        
        let destinationFolder;
        if (existingFolders.data.files && existingFolders.data.files.length > 0) {
          destinationFolder = existingFolders.data.files[0];
          console.log(`üìÇ S·ª≠ d·ª•ng th∆∞ m·ª•c ƒë√£ t·ªìn t·∫°i: ${destinationFolder.name} (${destinationFolder.id})`);
        } else {
          // T·∫°o th∆∞ m·ª•c m·ªõi
          const folderMetadata = {
            name: folder.data.name,
            mimeType: 'application/vnd.google-apps.folder',
            parents: [finalTargetFolderId]
          };
          
          const newFolder = await uploadDrive.files.create({
            resource: folderMetadata,
            fields: 'id, name, webViewLink',
            supportsAllDrives: true
          });
          
          destinationFolder = newFolder.data;
          console.log(`üìÇ ƒê√£ t·∫°o th∆∞ m·ª•c m·ªõi: ${destinationFolder.name} (${destinationFolder.id})`);
        }
        
        // L·∫•y danh s√°ch file v√† th∆∞ m·ª•c con
        console.log(`üìÇ L·∫•y danh s√°ch file v√† th∆∞ m·ª•c con trong th∆∞ m·ª•c ngu·ªìn`);
        const listResult = await downloadDrive.files.list({
          q: `'${finalFileId}' in parents and trashed = false`,
          fields: 'files(id, name, mimeType)',
          supportsAllDrives: true
        });
        
        const files = listResult.data.files || [];
        console.log(`üìÇ T√¨m th·∫•y ${files.length} file/folder trong th∆∞ m·ª•c ngu·ªìn`);
        
        // X·ª≠ l√Ω t·ª´ng file v√† th∆∞ m·ª•c con
        const processedFiles = [];
        const skippedFiles = [];
        const errorFiles = [];
        const subFolders = [];
        
        // X·ª≠ l√Ω c√°c th∆∞ m·ª•c con tr∆∞·ªõc
        const folderItems = files.filter(file => file.mimeType === 'application/vnd.google-apps.folder');
        console.log(`üìÅ T√¨m th·∫•y ${folderItems.length} th∆∞ m·ª•c con`);
        
        for (const folderItem of folderItems) {
          try {
            console.log(`üìÅ Ghi nh·∫≠n th∆∞ m·ª•c con: ${folderItem.name} (ID: ${folderItem.id})`);
            
            // T·∫°o th∆∞ m·ª•c con trong th∆∞ m·ª•c ƒë√≠ch
            console.log(`üìÅ Th√™m v√†o danh s√°ch th∆∞ m·ª•c con ƒë·ªÉ x·ª≠ l√Ω sau: ${folderItem.name}`);
            
            // Trong phi√™n b·∫£n ƒë·∫ßu ti√™n, ch√∫ng ta ch·ªâ ghi nh·∫≠n th∆∞ m·ª•c con, kh√¥ng x·ª≠ l√Ω ƒë·ªá quy
            // TODO: Th√™m x·ª≠ l√Ω ƒë·ªá quy trong phi√™n b·∫£n sau
            
            subFolders.push({
              id: folderItem.id,
              name: folderItem.name,
              link: `https://drive.google.com/drive/folders/${folderItem.id}`,
              // ƒê√°nh d·∫•u l√† th∆∞ m·ª•c con c·∫ßn x·ª≠ l√Ω sau
              needsProcessing: true
            });
          } catch (error) {
            console.error(`‚ùå L·ªói v·ªõi th∆∞ m·ª•c con ${folderItem.name}: ${error.message}`);
            errorFiles.push({
              id: folderItem.id,
              name: folderItem.name,
              error: error.message,
              isFolder: true
            });
          }
        }
        
        // X·ª≠ l√Ω c√°c file
        const fileItems = files.filter(file => file.mimeType !== 'application/vnd.google-apps.folder');
        console.log(`üìÑ T√¨m th·∫•y ${fileItems.length} file ƒë·ªÉ x·ª≠ l√Ω`);
        
        for (const fileItem of fileItems) {
          try {
            console.log(`üìÑ ƒêang ph√¢n t√≠ch file: ${fileItem.name} (ID: ${fileItem.id})`);
            
            // Ki·ªÉm tra MIME type
            let isPdf = false;
            let isVideo = false;
            let mimeTypeInfo = null;
            
            try {
              console.log(`üìÑ Ki·ªÉm tra MIME type cho file: ${fileItem.name} (ID: ${fileItem.id})`);
              const mimeTypeResult = await checkMimeType(fileItem.id).catch(e => {
                console.error(`‚ö†Ô∏è L·ªói khi g·ªçi checkMimeType: ${e.message}`);
                return {
                  success: false,
                  mimeType: fileItem.mimeType,
                  isPdf: fileItem.mimeType === 'application/pdf' || fileItem.name.toLowerCase().endsWith('.pdf'),
                  isVideo: fileItem.mimeType.includes('video'),
                  error: e.message
                };
              });
              
              if (!mimeTypeResult.success) {
                console.log(`‚ö†Ô∏è checkMimeType kh√¥ng th√†nh c√¥ng, s·ª≠ d·ª•ng th√¥ng tin m·∫∑c ƒë·ªãnh`);
              }
              
              isPdf = mimeTypeResult.isPdf;
              isVideo = fileItem.mimeType.includes('video') || mimeTypeResult.mimeType?.includes('video');
              mimeTypeInfo = mimeTypeResult;
              
              console.log(`üìÑ K·∫øt qu·∫£ ki·ªÉm tra MIME: ${fileItem.name} - isPDF=${isPdf}, isVideo=${isVideo}, mimeType=${mimeTypeResult.mimeType || fileItem.mimeType}`);
            } catch (mimeError) {
              console.error(`‚ùå L·ªói ki·ªÉm tra MIME type cho ${fileItem.name}: ${mimeError.message}`);
              // Fallback d·ª±a tr√™n t√™n file v√† mime type
              isPdf = fileItem.mimeType === 'application/pdf' || fileItem.name.toLowerCase().endsWith('.pdf');
              isVideo = fileItem.mimeType.includes('video');
              console.log(`üìÑ S·ª≠ d·ª•ng fallback: ${fileItem.name} - isPDF=${isPdf}, isVideo=${isVideo}, mimeType=${fileItem.mimeType}`);
            }
            
            if (isPdf || isVideo) {
              console.log(`‚úÖ Th√™m v√†o danh s√°ch file ƒë√£ x·ª≠ l√Ω: ${fileItem.name} (${isPdf ? 'PDF' : 'Video'})`);
              processedFiles.push({
                id: fileItem.id,
                name: fileItem.name,
                type: isPdf ? 'pdf' : 'video',
                mimeType: mimeTypeInfo?.mimeType || fileItem.mimeType,
                processed: true
              });
            } else {
              console.log(`‚ö†Ô∏è B·ªè qua file kh√¥ng ƒë∆∞·ª£c h·ªó tr·ª£: ${fileItem.name} (${mimeTypeInfo?.mimeType || fileItem.mimeType})`);
              skippedFiles.push({
                id: fileItem.id,
                name: fileItem.name,
                reason: `Kh√¥ng ph·∫£i file PDF ho·∫∑c video (${mimeTypeInfo?.mimeType || fileItem.mimeType})`
              });
            }
          } catch (error) {
            console.error(`‚ùå L·ªói x·ª≠ l√Ω file ${fileItem.name}: ${error.message}`);
            errorFiles.push({
              id: fileItem.id,
              name: fileItem.name,
              error: error.message
            });
          }
        }
        
        // Th·ª±c hi·ªán c·∫≠p nh·∫≠t sheet n·∫øu c·∫ßn
        let sheetUpdateResult = null;
        if (updateSheet) {
          try {
            console.log(`\nüìù C·∫≠p nh·∫≠t li√™n k·∫øt th∆∞ m·ª•c trong sheet...`);
            
            if (canUpdateSheet) {
              if (courseId && sheetIndex !== undefined && rowIndex !== undefined && cellIndex !== undefined) {
                sheetUpdateResult = await updateSheetCell(
                  courseId,
                  sheetIndex,
                  rowIndex,
                  cellIndex,
                  driveLink || `https://drive.google.com/drive/folders/${finalFileId}`,
                  destinationFolder.webViewLink,
                  displayText || folder.data.name,
                  request
                );
              } else if (sheetId && googleSheetName && rowIndex !== undefined && cellIndex !== undefined) {
                sheetUpdateResult = await updateGoogleSheetCell(
                  sheetId,
                  googleSheetName,
                  rowIndex,
                  cellIndex,
                  displayText || folder.data.name,
                  destinationFolder.webViewLink,
                  driveLink || `https://drive.google.com/drive/folders/${finalFileId}`,
                  request
                );
              }
            }
          } catch (sheetError) {
            console.error(`‚ùå L·ªói c·∫≠p nh·∫≠t sheet: ${sheetError.message}`);
          }
        }

        // X√¢y d·ª±ng k·∫øt qu·∫£
        const folderResult = {
          success: true,
          isFolder: true,
          folderId: finalFileId,
          folderName: folder.data.name,
          originalFolderLink: driveLink || `https://drive.google.com/drive/folders/${finalFileId}`,
          folderLink: destinationFolder.webViewLink,
          processedFolderLink: destinationFolder.webViewLink,
          processedFiles,
          skippedFiles,
          errors: errorFiles,
          subFolders,
          sheetUpdate: sheetUpdateResult
        };

      // Log total processing time
      const processingTime = Math.round((Date.now() - startTime) / 1000);
      console.log('\n=== HO√ÄN TH√ÄNH X·ª¨ L√ù TH∆Ø M·ª§C ===');
      console.log(`‚è±Ô∏è T·ªïng th·ªùi gian: ${processingTime} gi√¢y`);
        console.log(`üìä T·ªïng s·ªë file ƒë√£ x·ª≠ l√Ω: ${processedFiles.length}`);
        console.log(`‚ö†Ô∏è T·ªïng s·ªë file ƒë√£ b·ªè qua: ${skippedFiles.length}`);
        console.log(`‚ùå T·ªïng s·ªë l·ªói: ${errorFiles.length}`);

      return NextResponse.json({
        ...folderResult,
          processingTime,
          originalUrl: driveLink,
          urlType: 'folder'
      });
      } catch (folderError) {
        console.error(`‚ùå L·ªói x·ª≠ l√Ω th∆∞ m·ª•c: ${folderError.message}`);
        throw folderError;
      }
    }

    // Check if it's a Google Doc
    if (mimeTypeResult.isGoogleDoc) {
      throw new Error('Kh√¥ng th·ªÉ x·ª≠ l√Ω Google Doc, ch·ªâ file PDF ƒë∆∞·ª£c h·ªó tr·ª£');
    }

    // N·∫øu kh√¥ng ph·∫£i PDF, b·ªè qua x·ª≠ l√Ω watermark
    // Ki·ªÉm tra c·∫£ MIME type v√† ƒëu√¥i file
    const isPDF = mimeTypeResult.isPdf || driveLink.toLowerCase().endsWith('.pdf') || 
                (displayText && displayText.toLowerCase().endsWith('.pdf'));
                
    // X·ª≠ l√Ω m·ªçi lo·∫°i file, kh√¥ng ch·ªâ PDF
    // B·ªè qua ki·ªÉm tra isPDF
    /*
    if (!isPDF) {
      console.log(`‚ö†Ô∏è File kh√¥ng ph·∫£i l√† PDF (${mimeTypeResult.mimeType}), b·ªè qua x·ª≠ l√Ω watermark`);
      return NextResponse.json({
        success: true,
        skipped: true,
        message: `File kh√¥ng ph·∫£i l√† PDF (${mimeTypeResult.mimeType}), b·ªè qua x·ª≠ l√Ω watermark`,
        originalFile: {
          id: finalFileId,
          link: driveLink
        }
      });
    }
    */

    // T·∫°o th∆∞ m·ª•c t·∫°m n·∫øu ch∆∞a c√≥
    if (!fs.existsSync(tempDir)) {
      fs.mkdirSync(tempDir, { recursive: true });
    }

    // X·ª≠ l√Ω file ƒë∆°n l·∫ª
    const fileOptions = {
      targetFolderId: finalTargetFolderId,
      apiKey,
      updateSheet: canUpdateSheet, // S·ª≠ d·ª•ng bi·∫øn canUpdateSheet thay v√¨ updateSheet tr·ª±c ti·∫øp
      courseId,
      sheetIndex,
      rowIndex,
      cellIndex,
      sheetId,
      googleSheetName,
      displayText: originalFileName || displayText, // ∆Øu ti√™n s·ª≠ d·ª•ng t√™n file g·ªëc
      request
    };
    
    try {
      console.log('\nüìÑ X·ª¨ L√ù FILE ƒê∆†N L·∫∫');
      
      // Th√™m x·ª≠ l√Ω l·ªói v·ªõi catch ƒë·ªÉ x·ª≠ l√Ω c√°c tr∆∞·ªùng h·ª£p ƒë·∫∑c bi·ªát
      const fileResult = await processSingleFile(
        {
          id: finalFileId,
          name: originalFileName || displayText || `file_${finalFileId}`, // ∆Øu ti√™n s·ª≠ d·ª•ng t√™n file g·ªëc
          mimeType: mimeTypeResult.mimeType
        },
        fileOptions
      ).catch(async error => {
        console.error(`‚ùå L·ªói trong qu√° tr√¨nh x·ª≠ l√Ω file: ${error.message}`);
        
        // Ki·ªÉm tra l·ªói t·ª´ API x·ª≠ l√Ω watermark
        if (error.message.includes('L·ªói khi x·ª≠ l√Ω PDF') || 
            error.message.includes('X·ª≠ l√Ω th·∫•t b·∫°i') || 
            error.message.includes('Kh√¥ng th·ªÉ x·ª≠ l√Ω PDF')) {
          
          console.log(`‚ö†Ô∏è Ph√°t hi·ªán l·ªói t·ª´ API x·ª≠ l√Ω watermark, th·ª≠ d√πng Chrome...`);
          
          // Chuy·ªÉn sang Chrome n·∫øu c√≥ l·ªói API watermark
          return { 
            error: error.message, 
            useChrome: true 
          };
        }
        
        // N·∫øu l√† l·ªói 403 ho·∫∑c l·ªói download, chuy·ªÉn sang Chrome
        if (error.message.includes('403') || 
            error.message.includes('cannotDownloadFile') || 
            error.message.includes('download failed') ||
            error.message.includes('kh√¥ng th·ªÉ t·∫£i')) {
          
          console.log(`‚ö†Ô∏è L·ªói t·∫£i xu·ªëng file, chuy·ªÉn sang d√πng Chrome...`);
          return { 
            error: error.message, 
            useChrome: true 
          };
        }
        
        // N·∫øu l√† l·ªói kh√°c kh√¥ng x·ª≠ l√Ω ƒë∆∞·ª£c, n√©m ra ƒë·ªÉ x·ª≠ l√Ω ·ªü catch b√™n ngo√†i
        throw error;
      });
      
      // N·∫øu c·∫ßn s·ª≠ d·ª•ng Chrome ƒë·ªÉ x·ª≠ l√Ω
      if (fileResult && fileResult.error && fileResult.useChrome) {
        console.log('üåê Chuy·ªÉn sang Chrome ƒë·ªÉ t·∫£i v√† x·ª≠ l√Ω file...');
        
        // Th√™m v√†o h√†ng ƒë·ª£i x·ª≠ l√Ω Chrome
        const chromeResult = await addToProcessingQueue({
          fileId: finalFileId,
          fileName: originalFileName || displayText || `file_${finalFileId}`, // ∆Øu ti√™n s·ª≠ d·ª•ng t√™n file g·ªëc
          driveLink,
          targetFolderId: finalTargetFolderId,
          targetFolderName: finalFolderName,
          errorType: '403',
          updateSheet,
            courseId,
            sheetIndex,
            rowIndex,
            cellIndex,
            sheetId,
            googleSheetName,
          displayText: originalFileName || displayText, // ∆Øu ti√™n s·ª≠ d·ª•ng t√™n file g·ªëc
          request,
          tempDir
        });
        
        if (chromeResult) {
          return NextResponse.json({
            ...chromeResult,
            processingMode: 'chrome_after_error',
            originalError: fileResult.error
          });
      }
      
      return NextResponse.json({
          status: 'queued',
          message: 'File ƒë√£ ƒë∆∞·ª£c th√™m v√†o h√†ng ƒë·ª£i x·ª≠ l√Ω Chrome sau khi g·∫∑p l·ªói API',
          originalError: fileResult.error
        });
      }
      
      // T√≠nh th·ªùi gian x·ª≠ l√Ω
      const processingTime = Math.round((Date.now() - startTime) / 1000);
      console.log(`\n‚úÖ Ho√†n th√†nh x·ª≠ l√Ω file: ${processingTime} gi√¢y`);
      
      return NextResponse.json({
        ...fileResult,
        processingTime
      });
    } catch (error) {
      // N·∫øu l·ªói 403, th·ª≠ d√πng Chrome
      if (error.message.includes('HTTP 403') || error.message.includes('cannotDownloadFile')) {
        console.log('‚ö†Ô∏è 403 ƒë∆∞·ª£c ph√°t hi·ªán - File b·ªã ch·∫∑n t·∫£i xu·ªëng');
        console.log('üåê Chuy·ªÉn sang Chrome ƒë·ªÉ t·∫£i v√† x·ª≠ l√Ω file...');
        
        // Th√™m v√†o h√†ng ƒë·ª£i x·ª≠ l√Ω Chrome
        const chromeResult = await addToProcessingQueue({
          fileId: finalFileId,
          fileName: originalFileName || displayText || `file_${finalFileId}`, // ∆Øu ti√™n s·ª≠ d·ª•ng t√™n file g·ªëc
          driveLink,
          targetFolderId: finalTargetFolderId,
          targetFolderName: finalFolderName,
          errorType: '403',
          updateSheet,
          courseId,
          sheetIndex,
          rowIndex,
          cellIndex,
          sheetId,
          googleSheetName,
          displayText: originalFileName || displayText, // ∆Øu ti√™n s·ª≠ d·ª•ng t√™n file g·ªëc
          request,
          tempDir
        });
        
        if (chromeResult) {
          return NextResponse.json(chromeResult);
        }
        
        return NextResponse.json({ 
          status: 'queued',
          message: 'File ƒë√£ ƒë∆∞·ª£c th√™m v√†o h√†ng ƒë·ª£i x·ª≠ l√Ω Chrome'
        });
      }
      
      // N·∫øu l√† l·ªói kh√°c, n√©m l·ªói ƒë·ªÉ x·ª≠ l√Ω ·ªü catch
      throw error;
    }
  } catch (error) {
    console.error(`‚ùå L·ªói x·ª≠ l√Ω file: ${error.message}`);
    
    // G·ª≠i th√¥ng b√°o l·ªói
    await sendUpdate({
      type: 'error',
      error: error.message
    });
    
    // ƒê√≥ng stream
    await writer.close();
    
    return new Response(
      JSON.stringify({ error: `L·ªói x·ª≠ l√Ω file: ${error.message}` }), 
      { 
        status: 500,
        headers: {
          'Content-Type': 'application/json',
        }
      }
    );
  } finally {
    // D·ªçn d·∫πp th∆∞ m·ª•c t·∫°m
    if (fs.existsSync(tempDir)) {
      try {
        fs.rmSync(tempDir, { recursive: true, force: true });
        console.log(`üßπ ƒê√£ x√≥a th∆∞ m·ª•c t·∫°m: ${tempDir}`);
      } catch (cleanupError) {
        console.error(`‚ö†Ô∏è L·ªói d·ªçn d·∫πp th∆∞ m·ª•c t·∫°m: ${cleanupError.message}`);
      }
    }
    
    // ƒê·∫£m b·∫£o stream ƒë∆∞·ª£c ƒë√≥ng
    try {
      await writer.close();
    } catch (e) {
      console.error('L·ªói ƒë√≥ng stream:', e);
    }
  }
  
  // Tr·∫£ v·ªÅ stream response
  return new Response(customStream.readable, {
    headers: {
      'Content-Type': 'text/event-stream',
      'Cache-Control': 'no-cache',
      'Connection': 'keep-alive',
    },
  });
}