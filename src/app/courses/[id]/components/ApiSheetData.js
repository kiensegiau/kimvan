import { useState, useEffect, useCallback } from 'react';
import { ArrowPathIcon } from '@heroicons/react/24/outline';
import YouTubeModal from './YouTubeModal';
import YouTubePlaylistModal from './YouTubePlaylistModal';
import PDFModal from './PDFModal';

export default function ApiSheetData({ 
  apiSheetData, 
  loadingApiSheet, 
  apiSheetError,
  activeApiSheet,
  setActiveApiSheet,
  fetchApiSheetData,
  fetchSheetDetail
}) {
  const [selectedVideo, setSelectedVideo] = useState(null);
  const [selectedPlaylist, setSelectedPlaylist] = useState(null);
  const [selectedPlaylistVideo, setSelectedPlaylistVideo] = useState(null);
  const [selectedPDF, setSelectedPDF] = useState(null);
  const [pdfTitle, setPdfTitle] = useState('');
  const [loadingLinks, setLoadingLinks] = useState({});
  const [sortConfig, setSortConfig] = useState({ key: null, direction: 'ascending' });
  const [hoveredHeader, setHoveredHeader] = useState(null);
  const [processingSheet, setProcessingSheet] = useState(false);
  
  // T·∫°o proxy link t·ª´ URL th√¥ng qua Base64 encoding
  const createProxyLink = useCallback((url) => {
    try {
      // M√£ h√≥a URL s·ª≠ d·ª•ng base64 URL-safe
      const base64Url = Buffer.from(url).toString('base64')
        .replace(/\+/g, '-')  // Thay th·∫ø + th√†nh -
        .replace(/\//g, '_')  // Thay th·∫ø / th√†nh _
        .replace(/=+$/, '');  // Lo·∫°i b·ªè padding '='
      
      return `/api/proxy-link/${base64Url}`;
    } catch (error) {
      console.error('L·ªói khi t·∫°o proxy link:', error);
      return null;
    }
  }, []);
  
  // Track changes to selectedVideo
  useEffect(() => {
    console.log('selectedVideo state changed:', selectedVideo);
  }, [selectedVideo]);
  
  // Gi·∫£i m√£ proxy link ƒë·ªÉ l·∫•y URL g·ªëc
  const decodeProxyLink = useCallback((proxyUrl) => {
    try {
      if (!proxyUrl || !proxyUrl.startsWith('/api/proxy-link/')) {
        return null;
      }
      
      // L·∫•y ph·∫ßn base64 t·ª´ URL
      const base64Part = proxyUrl.replace('/api/proxy-link/', '');
      
      // Chuy·ªÉn l·∫°i c√°c k√Ω t·ª± ƒë·∫∑c bi·ªát
      const normalizedBase64 = base64Part
        .replace(/-/g, '+')  // Thay th·∫ø - th√†nh +
        .replace(/_/g, '/'); // Thay th·∫ø _ th√†nh /
      
      // Gi·∫£i m√£ base64
      const decodedUrl = Buffer.from(normalizedBase64, 'base64').toString('utf-8');
      return decodedUrl;
    } catch (error) {
      console.error('L·ªói khi gi·∫£i m√£ proxy link:', error);
      return null;
    }
  }, []);

  // Ki·ªÉm tra v√† t·∫£i chi ti·∫øt sheet n·∫øu c·∫ßn
  useEffect(() => {
    if (apiSheetData && apiSheetData.sheets && apiSheetData.sheets.length > 0) {
      const currentSheet = apiSheetData.sheets[activeApiSheet];
      
      // Log th√¥ng tin sheet hi·ªán t·∫°i
      if (currentSheet) {
        console.log('üìë Th√¥ng tin sheet hi·ªán t·∫°i:');
        console.log('Sheet ID:', currentSheet._id);
        console.log('Sheet Name:', currentSheet.name || currentSheet.detail?.name || 'Kh√¥ng c√≥ t√™n');
        
        // Ki·ªÉm tra v√† log c·∫•u tr√∫c d·ªØ li·ªáu chi ti·∫øt
        if (currentSheet.detail) {
          console.log('C·∫•u tr√∫c d·ªØ li·ªáu chi ti·∫øt:', currentSheet.detail);
          
          // Ki·ªÉm tra c·∫•u tr√∫c d·ªØ li·ªáu v√† log ph√π h·ª£p
          if (Array.isArray(currentSheet.detail.header) && Array.isArray(currentSheet.detail.rows)) {
            console.log('Header:', currentSheet.detail.header);
            console.log('Rows:', currentSheet.detail.rows);
            console.log('Total Rows:', currentSheet.detail.rows.length);
            console.log('Sheet Name from detail:', currentSheet.detail.name || 'Kh√¥ng c√≥ t√™n trong detail');
          } else if (Array.isArray(currentSheet.detail.values)) {
            console.log('Values:', currentSheet.detail.values);
            console.log('Total Rows:', currentSheet.detail.values.length - 1);
            console.log('Sheet Name from detail:', currentSheet.detail.name || 'Kh√¥ng c√≥ t√™n trong detail');
          }
        }
      }
      
      // N·∫øu c√≥ sheet nh∆∞ng kh√¥ng c√≥ chi ti·∫øt, t·∫£i chi ti·∫øt
      if (currentSheet && !currentSheet.detail && !loadingApiSheet) {
        fetchSheetDetail(currentSheet._id);
      }
    }
  }, [apiSheetData, activeApiSheet, loadingApiSheet, fetchSheetDetail]);

  const isYoutubeLink = (url) => {
    if (!url) return false;
    
    // Ki·ªÉm tra URL YouTube th√¥ng th∆∞·ªùng
    const isRegularYoutube = url.includes('youtube.com') || 
                            url.includes('youtu.be') || 
                            url.includes('youtube-nocookie.com') ||
                            url.includes('youtube.googleapis.com');
    
    // Log ƒë·ªÉ debug
    if (isRegularYoutube) {
      console.log(`Ph√°t hi·ªán YouTube link: ${url}`);
    }
    
    return isRegularYoutube;
  };
  
  const isPdfLink = (url) => {
    if (!url) return false;
    return url.toLowerCase().endsWith('.pdf');
  };
  
  const isGoogleDriveLink = (url) => {
    if (!url) return false;
    return url.includes('drive.google.com') || url.includes('docs.google.com');
  };

  // H√†m l·∫•y video ID t·ª´ URL YouTube
  const getYoutubeVideoId = (url) => {
    if (!url) return null;
    
    console.log('Extracting video ID from URL:', url);
    
    // X·ª≠ l√Ω c√°c ƒë·ªãnh d·∫°ng URL YouTube kh√°c nhau
    let videoId = null;
    
    // Format: https://www.youtube.com/watch?v=VIDEO_ID
    const watchMatch = url.match(/(?:youtube\.com\/watch\?v=|youtu\.be\/|youtube\.com\/embed\/|youtube\.com\/v\/|youtube\.com\/e\/|youtube\.com\/watch\?.*v=|youtube\.com\/attribution_link\?.*v%3D|youtube\.com\/attribution_link\?.*v=|youtube-nocookie\.com\/.*v=|youtube\.com\/shorts\/)([^&\n?#\/]+)/);
    
    if (watchMatch) {
      videoId = watchMatch[1];
      console.log('Found video ID from regex:', videoId);
    }
    
    return videoId;
  };

  const isYoutubePlaylist = (url) => {
    if (!url) return false;
    
    // Ki·ªÉm tra c√°c ƒë·ªãnh d·∫°ng URL playlist YouTube
    return url.includes('youtube.com/playlist') || 
           url.includes('youtube.com/watch') && url.includes('list=');
  };

  const getYoutubePlaylistId = (url) => {
    if (!url) return null;
    
    console.log('Extracting playlist ID from URL:', url);
    
    // X·ª≠ l√Ω c√°c ƒë·ªãnh d·∫°ng URL playlist YouTube kh√°c nhau
    let playlistId = null;
    
    // Format: youtube.com/playlist?list=PLAYLIST_ID
    // ho·∫∑c: youtube.com/watch?v=VIDEO_ID&list=PLAYLIST_ID
    const playlistMatch = url.match(/[&?]list=([^&]+)/);
    
    if (playlistMatch) {
      playlistId = playlistMatch[1];
      console.log('Found playlist ID:', playlistId);
    }
    
    return playlistId;
  };

  const handleYoutubeClick = (e, url) => {
    e.preventDefault();
    console.log('X·ª≠ l√Ω YouTube click:', url);
    
    // Ki·ªÉm tra n·∫øu l√† playlist
    if (isYoutubePlaylist(url)) {
      const playlistId = getYoutubePlaylistId(url);
      const videoId = getYoutubeVideoId(url);
      console.log('Detected playlist:', playlistId, 'with video:', videoId);
      
      if (playlistId) {
        setSelectedPlaylist(playlistId);
        setSelectedPlaylistVideo(videoId); // C√≥ th·ªÉ null n·∫øu kh√¥ng c√≥ video c·ª• th·ªÉ
        return;
      }
    }
    
    // X·ª≠ l√Ω video ƒë∆°n l·∫ª nh∆∞ c≈©
    const videoId = getYoutubeVideoId(url);
    console.log('Extracted YouTube video ID:', videoId);
    
    if (videoId) {
      console.log('ƒê√£ t√¨m th·∫•y video ID:', videoId);
      setSelectedVideo(videoId);
      console.log('Set selectedVideo state to:', videoId);
    } else {
      console.log('Kh√¥ng t√¨m th·∫•y video ID, m·ªü URL trong tab m·ªõi');
      window.open(url, '_blank');
    }
  };

  const handlePdfClick = (e, url, title = '') => {
    e.preventDefault();
    setSelectedPDF(url);
    setPdfTitle(title);
  };

  // Handle general link click with proxy link creation
  const handleLinkClick = (e, url, title = '') => {
    e.preventDefault();
    console.log('X·ª≠ l√Ω link click:', url, 'title:', title);
    
    // ƒê√°nh d·∫•u link ƒëang loading
    setLoadingLinks(prev => ({ ...prev, [url]: true }));
    
    // Ki·ªÉm tra n·∫øu l√† YouTube link
    if (isYoutubeLink(url)) {
      console.log('Ph√°t hi·ªán YouTube link, x·ª≠ l√Ω v·ªõi handleYoutubeClick');
      handleYoutubeClick(e, url);
      setTimeout(() => {
        setLoadingLinks(prev => ({ ...prev, [url]: false }));
      }, 500);
      return;
    }
    
    // Ki·ªÉm tra n·∫øu l√† proxy link, gi·∫£i m√£ ƒë·ªÉ x√°c ƒë·ªãnh lo·∫°i
    if (url.startsWith('/api/proxy-link/')) {
      const originalUrl = decodeProxyLink(url);
      console.log('Decoded proxy link:', originalUrl);
      
      // N·∫øu gi·∫£i m√£ th√†nh c√¥ng v√† l√† YouTube link
      if (originalUrl && isYoutubeLink(originalUrl)) {
        // X·ª≠ l√Ω nh∆∞ YouTube link
        console.log('Ph√°t hi·ªán YouTube link t·ª´ proxy, x·ª≠ l√Ω v·ªõi handleYoutubeClick');
        handleYoutubeClick(e, originalUrl);
        setTimeout(() => {
          setLoadingLinks(prev => ({ ...prev, [url]: false }));
        }, 500);
        return;
      }
      
      // N·∫øu gi·∫£i m√£ th√†nh c√¥ng v√† l√† PDF
      if (originalUrl && isPdfLink(originalUrl)) {
        console.log('Ph√°t hi·ªán PDF link t·ª´ proxy');
        handlePdfClick(e, url, title || 'Xem t√†i li·ªáu PDF');
        setTimeout(() => {
          setLoadingLinks(prev => ({ ...prev, [url]: false }));
        }, 500);
        return;
      }
      
      // N·∫øu gi·∫£i m√£ th√†nh c√¥ng v√† l√† Google Drive
      if (originalUrl && isGoogleDriveLink(originalUrl)) {
        // M·ªü Google Drive trong tab m·ªõi
        console.log('Ph√°t hi·ªán Google Drive link t·ª´ proxy');
        window.open(originalUrl, '_blank');
        setTimeout(() => {
          setLoadingLinks(prev => ({ ...prev, [url]: false }));
        }, 500);
        return;
      }
      
      // N·∫øu kh√¥ng ph·∫£i YouTube ho·∫∑c PDF, hi·ªÉn th·ªã trong PDF Modal
      console.log('Link kh√¥ng ƒë∆∞·ª£c nh·∫≠n d·∫°ng, x·ª≠ l√Ω nh∆∞ t√†i li·ªáu chung');
      handlePdfClick(e, url, title || 'Xem t√†i li·ªáu');
      setTimeout(() => {
        setLoadingLinks(prev => ({ ...prev, [url]: false }));
      }, 500);
      return;
    }
    
    // X·ª≠ l√Ω c√°c lo·∫°i link kh√°c
    if (isPdfLink(url)) {
      console.log('Ph√°t hi·ªán PDF link');
      handlePdfClick(e, url, title);
    } else if (isGoogleDriveLink(url)) {
      console.log('Ph√°t hi·ªán Google Drive link');
      window.open(url, '_blank');
    } else {
      // T·∫°o proxy URL b·∫±ng base64 cho c√°c link kh√°c
      const proxyUrl = createProxyLink(url);
      if (proxyUrl) {
        console.log('T·∫°o proxy link th√†nh c√¥ng:', proxyUrl);
        handlePdfClick(e, proxyUrl, title || 'Xem t√†i li·ªáu');
      } else {
        console.warn('Kh√¥ng th·ªÉ t·∫°o proxy link, m·ªü URL g·ªëc:', url);
        handlePdfClick(e, url, title || 'Xem t√†i li·ªáu');
      }
    }
    
    // ƒê√°nh d·∫•u link ƒë√£ xong loading
    setTimeout(() => {
      setLoadingLinks(prev => ({ ...prev, [url]: false }));
    }, 500);
  };
  
  // H√†m l·∫•y hyperlink t·ª´ d·ªØ li·ªáu
  const getHyperlink = (rowIndex, cellIndex, data) => {
    if (!data) return null;
    
    // Ki·ªÉm tra n·∫øu c√≥ hyperlinks trong c·∫•u tr√∫c m·ªõi
    if (Array.isArray(data.hyperlinks)) {
      const hyperlink = data.hyperlinks.find(link => link.row === rowIndex && link.col === cellIndex);
      if (hyperlink) return hyperlink.url;
    }
    
    // Ki·ªÉm tra n·∫øu c√≥ c·∫•u tr√∫c rows v·ªõi _hyperlinks
    if (Array.isArray(data.rows) && rowIndex < data.rows.length) {
      const row = data.rows[rowIndex];
      if (row && row._hyperlinks && Array.isArray(data.header) && cellIndex < data.header.length) {
        const columnName = data.header[cellIndex];
        if (columnName && row._hyperlinks[columnName]) {
          return row._hyperlinks[columnName];
        }
      }
      
      // Ki·ªÉm tra n·∫øu c√≥ processedData.urls
      if (row && row.processedData && Array.isArray(row.processedData.urls)) {
        const urlData = row.processedData.urls.find(url => url.colIndex === cellIndex);
        if (urlData && urlData.url) {
          return urlData.url;
        }
      }
    }
    
    // Ki·ªÉm tra n·∫øu c√≥ htmlData (cho kh·∫£ nƒÉng t∆∞∆°ng th√≠ch ng∆∞·ª£c)
    if (data.htmlData && Array.isArray(data.htmlData) && data.htmlData.length > rowIndex) {
      const htmlRow = data.htmlData[rowIndex];
      if (htmlRow && htmlRow.values && htmlRow.values.length > cellIndex) {
        const htmlCell = htmlRow.values[cellIndex];
        if (htmlCell && htmlCell.hyperlink) {
          return htmlCell.hyperlink;
        }
      }
    }
    
    return null;
  };

  // Tr√≠ch xu·∫•t URL th·ª±c t·ª´ n·ªôi dung cell
  const extractRealUrl = (content) => {
    if (!content) return null;
    
    // N·∫øu content l√† chu·ªói v√† ch·ª©a URL
    if (typeof content === 'string') {
      // T√¨m c√°c URL ph·ªï bi·∫øn
      const urlPattern = /(https?:\/\/[^\s]+)/gi;
      const matches = content.match(urlPattern);
      
      if (matches && matches.length > 0) {
        console.log('Tr√≠ch xu·∫•t ƒë∆∞·ª£c URL t·ª´ n·ªôi dung:', matches[0]);
        return matches[0];
      }
      
      // T√¨m ID YouTube t·ª´ c√°c ƒë·ªãnh d·∫°ng ph·ªï bi·∫øn
      const ytIdPatterns = [
        /youtube\.com.*[?&]v=([^&]+)/i,  // youtube.com?v=ID
        /youtu\.be\/([^?&]+)/i,          // youtu.be/ID
        /youtube\.com\/embed\/([^?&]+)/i // youtube.com/embed/ID
      ];
      
      for (const pattern of ytIdPatterns) {
        const match = content.match(pattern);
        if (match && match[1]) {
          const videoId = match[1];
          console.log('Tr√≠ch xu·∫•t ƒë∆∞·ª£c YouTube ID t·ª´ n·ªôi dung:', videoId);
          return `https://www.youtube.com/watch?v=${videoId}`;
        }
      }
      
      // T√¨m s·ªë c·ªôt n·∫øu c√≥ (c√≥ th·ªÉ l√† s·ªë ƒëi·ªán tho·∫°i ho·∫∑c m√£ s·ªë)
      // Nh∆∞ng ch·ªâ n·∫øu l√† c·ªôt CH∆Ø∆†NG
      const numberPattern = /(\d{5,})/g;
      const numberMatches = content.match(numberPattern);
      
      if (numberMatches && numberMatches.length > 0) {
        const number = numberMatches[0];
        console.log('T√¨m th·∫•y s·ªë c√≥ th·ªÉ l√† m√£ video:', number);
        
        // Ki·ªÉm tra xem c√≥ ph·∫£i l√† ID YouTube kh√¥ng (th∆∞·ªùng l√† 11 k√Ω t·ª±)
        if (number.length === 11) {
          console.log('S·ªë c√≥ ƒë·ªô d√†i ph√π h·ª£p v·ªõi YouTube ID:', number);
          return `https://www.youtube.com/watch?v=${number}`;
        }
      }
    }
    
    return null;
  };

  // H√†m render cell c√≥ hyperlink
  const renderHyperlinkCell = (hyperlink, cellContent, rowIndex, cellIndex) => {
    // N·∫øu kh√¥ng c√≥ hyperlink, hi·ªÉn th·ªã text th√¥ng th∆∞·ªùng
    if (!hyperlink) {
      return <span>{cellContent || ''}</span>;
    }

    // Check if it's a YouTube link first
    if (isYoutubeLink(hyperlink)) {
      console.log('renderHyperlinkCell: Detected YouTube link', hyperlink);
      // X√°c ƒë·ªãnh loading state
      const isLoading = loadingLinks[hyperlink];
      
      return (
        <button
          onClick={(e) => handleYoutubeClick(e, hyperlink)}
          className={`text-red-600 hover:text-red-800 hover:underline focus:outline-none ${
            isLoading ? 'opacity-50 cursor-wait' : ''
          }`}
          disabled={isLoading}
        >
          <span className="flex items-center space-x-1">
            {isLoading ? (
              <ArrowPathIcon className="h-4 w-4 animate-spin" />
            ) : (
              <svg className="h-4 w-4 mr-1 inline" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor">
                <path d="M19.615 3.184c-3.604-.246-11.631-.245-15.23 0-3.897.266-4.356 2.62-4.385 8.816.029 6.185.484 8.549 4.385 8.816 3.6.245 11.626.246 15.23 0 3.897-.266 4.356-2.62 4.385-8.816-.029-6.185-.484-8.549-4.385-8.816zm-10.615 12.816v-8l8 3.993-8 4.007z"/>
              </svg>
            )}
            <span>{cellContent || 'Xem video'}</span>
          </span>
        </button>
      );
    }

    // T·∫°o proxy link n·∫øu c·∫ßn
    let linkToUse = hyperlink;
    if (isGoogleDriveLink(hyperlink) || isPdfLink(hyperlink)) {
      linkToUse = createProxyLink(hyperlink) || hyperlink;
    }

    // X√°c ƒë·ªãnh loading state
    const isLoading = loadingLinks[hyperlink] || loadingLinks[linkToUse];
    
    return (
      <button
        onClick={(e) => handleLinkClick(e, linkToUse, cellContent)}
        className={`text-blue-600 hover:text-blue-800 hover:underline focus:outline-none ${
          isLoading ? 'opacity-50 cursor-wait' : ''
        }`}
        disabled={isLoading}
      >
        <span className="flex items-center space-x-1">
          {isLoading ? (
            <ArrowPathIcon className="h-4 w-4 animate-spin" />
          ) : null}
          <span>{cellContent || hyperlink}</span>
        </span>
      </button>
    );
  };

  // H√†m format n·ªôi dung cell, ƒë·∫∑c bi·ªát x·ª≠ l√Ω cho c√°c c·ªôt ng√†y th√°ng
  const formatCellContent = (content, column) => {
    // N·∫øu kh√¥ng c√≥ n·ªôi dung, tr·∫£ v·ªÅ chu·ªói r·ªóng
    if (content === null || content === undefined || content === '') {
      return '';
    }
    
    // Danh s√°ch c√°c c·ªôt ch·ª©a ng√†y th√°ng
    const dateCols = ['NG√ÄY H·ªåC', 'NG√ÄY', 'DATE', 'TH·ªúI GIAN'];
    const isDateColumn = column && dateCols.some(dateCol => 
      column.toUpperCase().includes(dateCol)
    );
    
    // X·ª≠ l√Ω ƒë·∫∑c bi·ªát cho c·ªôt ch·ª©a ng√†y th√°ng
    if (isDateColumn) {
      // Ki·ªÉm tra n·∫øu l√† s·ªë Excel serial date (v√≠ d·ª•: 45792)
      if (!isNaN(Number(content))) {
        // Excel serial date b·∫Øt ƒë·∫ßu t·ª´ ng√†y 1/1/1900, v√† s·ªë 1 t∆∞∆°ng ·ª©ng v·ªõi ng√†y 1/1/1900
        // M·ªôt s·ªë serial nh∆∞ 45792 l√† s·ªë ng√†y k·ªÉ t·ª´ 1/1/1900
        // Nh∆∞ng JavaScript date b·∫Øt ƒë·∫ßu t·ª´ 1/1/1970
        
        try {
          // Chuy·ªÉn ƒë·ªïi Excel serial date sang JavaScript Date
          // Excel c√≥ l·ªói v·ªõi nƒÉm 1900 (coi n√≥ nh∆∞ nƒÉm nhu·∫≠n), n√™n tr·ª´ ƒëi 1 n·∫øu s·ªë > 60
          let excelSerialDate = Number(content);
          
          // X·ª≠ l√Ω tr∆∞·ªùng h·ª£p Excel hi·ªÉn th·ªã s·ªë kh√¥ng c√≥ ƒë·ªãnh d·∫°ng (v√≠ d·ª•: 45792)
          // T√≠nh to√°n ng√†y t∆∞∆°ng ·ª©ng v·ªõi Excel serial date
          const millisecondsPerDay = 24 * 60 * 60 * 1000;
          
          // ƒêi·ªÅu ch·ªânh l·ªói nƒÉm 1900 trong Excel
          if (excelSerialDate > 60) {
            excelSerialDate -= 1;
          }
          
          // Ng√†y g·ªëc c·ªßa Excel l√† 1/1/1900
          const excelStartDate = new Date(1900, 0, 1);
          
          // T√≠nh to√°n ng√†y th·ª±c t·∫ø
          const targetDate = new Date(excelStartDate.getTime() + (excelSerialDate - 1) * millisecondsPerDay);
          
          // ƒê·ªãnh d·∫°ng ng√†y th√°ng theo dd/MM/yyyy
          const day = String(targetDate.getDate()).padStart(2, '0');
          const month = String(targetDate.getMonth() + 1).padStart(2, '0');
          const year = targetDate.getFullYear();
          
          return `${day}/${month}/${year}`;
        } catch (error) {
          console.error('L·ªói khi chuy·ªÉn ƒë·ªïi Excel serial date:', error);
          return content; // Tr·∫£ v·ªÅ gi√° tr·ªã g·ªëc n·∫øu c√≥ l·ªói
        }
      }
      
      // Ki·ªÉm tra n·∫øu l√† chu·ªói ng√†y th√°ng h·ª£p l·ªá
      try {
        const dateObj = new Date(content);
        if (!isNaN(dateObj.getTime())) {
          // ƒê·ªãnh d·∫°ng ng√†y th√°ng theo dd/MM/yyyy
          const day = String(dateObj.getDate()).padStart(2, '0');
          const month = String(dateObj.getMonth() + 1).padStart(2, '0');
          const year = dateObj.getFullYear();
          return `${day}/${month}/${year}`;
        }
      } catch (error) {
        console.error('L·ªói khi ƒë·ªãnh d·∫°ng chu·ªói ng√†y th√°ng:', error);
      }
    }
    
    // Tr·∫£ v·ªÅ n·ªôi dung g·ªëc n·∫øu kh√¥ng c·∫ßn x·ª≠ l√Ω ƒë·∫∑c bi·ªát
    return content;
  };

  // Render n·ªôi dung cell
  const renderCellContent = (content, rowIndex, cellIndex, sheetDetail) => {
    // L·∫•y hyperlink n·∫øu c√≥
    // Th·ª≠ nhi·ªÅu v·ªã tr√≠ kh√°c nhau ƒë·ªÉ t√¨m hyperlink
    let hyperlink = null;
    
    // Th·ª≠ v·ªã tr√≠ ch√≠nh x√°c tr∆∞·ªõc
    hyperlink = getHyperlink(rowIndex, cellIndex, sheetDetail);
    
    // N·∫øu kh√¥ng t√¨m th·∫•y, th·ª≠ m·ªôt s·ªë v·ªã tr√≠ kh√°c
    if (!hyperlink && rowIndex > 0) {
      // Th·ª≠ v·ªõi rowIndex - 1 (tr∆∞·ªùng h·ª£p htmlData kh√¥ng t√≠nh header)
      hyperlink = getHyperlink(rowIndex - 1, cellIndex, sheetDetail);
    }
    
    // N·∫øu v·∫´n kh√¥ng t√¨m th·∫•y v√† c√≥ htmlData, th·ª≠ t√¨m ki·∫øm d·ª±a tr√™n n·ªôi dung
    if (!hyperlink && sheetDetail.htmlData && content) {
      // T√¨m trong to√†n b·ªô htmlData c√°c √¥ c√≥ hyperlink v√† n·ªôi dung t∆∞∆°ng t·ª±
      sheetDetail.htmlData.forEach((row, rIdx) => {
        if (row && row.values && Array.isArray(row.values)) {
          row.values.forEach((cell, cIdx) => {
            if (cell && cell.hyperlink && cell.formattedValue === content) {
              console.log(`üîç T√¨m th·∫•y hyperlink d·ª±a tr√™n n·ªôi dung [${rIdx},${cIdx}]: ${cell.hyperlink}`);
              if (!hyperlink) hyperlink = cell.hyperlink;
            }
          });
        }
      });
    }
    
    // Th·ª≠ tr√≠ch xu·∫•t URL t·ª´ n·ªôi dung cell
    if (!hyperlink && content) {
      const columnName = sheetDetail.header?.[cellIndex];
      hyperlink = extractRealUrl(content);
      if (hyperlink) {
        console.log(`üîç Tr√≠ch xu·∫•t URL t·ª´ n·ªôi dung cell [${rowIndex},${cellIndex}] (${columnName}):`, hyperlink);
      }
    }
    
    // Debug ƒë·ªÉ x√°c ƒë·ªãnh v·ªã tr√≠
    if (hyperlink) {
      console.log(`‚úÖ T√¨m th·∫•y hyperlink cho cell [${rowIndex},${cellIndex}]: ${hyperlink}`);
    }
    
    // N·∫øu c√≥ hyperlink, render cell v·ªõi hyperlink
    if (hyperlink) {
      return renderHyperlinkCell(hyperlink, formatCellContent(content, sheetDetail.header?.[cellIndex]) || '', rowIndex, cellIndex);
    }
    
    // N·∫øu kh√¥ng c√≥ hyperlink, hi·ªÉn th·ªã n·ªôi dung th√¥ng th∆∞·ªùng
    return formatCellContent(content, sheetDetail.header?.[cellIndex]) || '';
  };

  // H√†m ki·ªÉm tra cell c√≥ b·ªã g·ªôp kh√¥ng
  const isMergedCell = (rowIndex, cellIndex, sheetDetail) => {
    if (!sheetDetail.merges) return false;
    
    // Ki·ªÉm tra xem cell c√≥ n·∫±m trong v√πng g·ªôp n√†o kh√¥ng
    return sheetDetail.merges.some(merge => {
      const isInMergeRange = 
        rowIndex >= merge.startRowIndex &&
        rowIndex < merge.endRowIndex &&
        cellIndex >= merge.startColumnIndex &&
        cellIndex < merge.endColumnIndex;
      
      // N·∫øu l√† cell ch√≠nh c·ªßa v√πng g·ªôp, tr·∫£ v·ªÅ false ƒë·ªÉ render
      const isMainCell = 
        rowIndex === merge.startRowIndex &&
        cellIndex === merge.startColumnIndex;
      
      return isInMergeRange && !isMainCell;
    });
  };

  // H√†m l·∫•y th√¥ng tin rowSpan v√† colSpan cho cell
  const getMergeInfo = (rowIndex, cellIndex, sheetDetail) => {
    if (!sheetDetail.merges) return null;
    
    // T√¨m v√πng g·ªôp m√† cell n√†y l√† cell ch√≠nh
    const merge = sheetDetail.merges.find(merge => 
      rowIndex === merge.startRowIndex &&
      cellIndex === merge.startColumnIndex
    );
    
    if (!merge) return null;
    
    return {
      rowSpan: merge.endRowIndex - merge.startRowIndex,
      colSpan: merge.endColumnIndex - merge.startColumnIndex
    };
  };
  
  // Sorting function
  const requestSort = (key) => {
    let direction = 'ascending';
    if (sortConfig.key === key && sortConfig.direction === 'ascending') {
      direction = 'descending';
    }
    setSortConfig({ key, direction });
  };

  // Get sorted data
  const getSortedData = (data, header) => {
    if (!sortConfig.key || !Array.isArray(data) || data.length === 0) return data;

    return [...data].sort((a, b) => {
      const columnName = header[sortConfig.key];
      if (!columnName) return 0;
      
      // Get values to compare
      let aValue = a[columnName];
      let bValue = b[columnName];
      
      // Handle undefined or null values
      if (aValue === undefined || aValue === null) aValue = '';
      if (bValue === undefined || bValue === null) bValue = '';

      // Try to detect value type and sort accordingly
      
      // Check if values are numbers
      const aNum = parseFloat(aValue);
      const bNum = parseFloat(bValue);
      if (!isNaN(aNum) && !isNaN(bNum)) {
        return sortConfig.direction === 'ascending' ? aNum - bNum : bNum - aNum;
      }

      // Check if values are dates
      const aDate = new Date(aValue);
      const bDate = new Date(bValue);
      if (!isNaN(aDate) && !isNaN(bDate) && aValue && bValue) {
        return sortConfig.direction === 'ascending' ? aDate - bDate : bDate - aDate;
      }

      // Handle objects with text property
      if (typeof aValue === 'object' && aValue !== null) {
        aValue = aValue.text || aValue.formattedValue || '';
      }
      if (typeof bValue === 'object' && bValue !== null) {
        bValue = bValue.text || bValue.formattedValue || '';
      }

      // Convert to strings for comparison
      aValue = String(aValue || '').toLowerCase();
      bValue = String(bValue || '').toLowerCase();

      // Compare strings
      if (sortConfig.direction === 'ascending') {
        return aValue.localeCompare(bValue, 'vi');
      }
      return bValue.localeCompare(aValue, 'vi');
    });
  };

  // H√†m debug c·∫•u tr√∫c d·ªØ li·ªáu
  const debugSheetStructure = (sheetDetail) => {
    if (!sheetDetail) {
      console.log('‚ùå Kh√¥ng c√≥ d·ªØ li·ªáu sheet');
      return;
    }
    
    console.log('üîç DEBUG SHEET STRUCTURE:');
    
    // Ki·ªÉm tra c√°c thu·ªôc t√≠nh ch√≠nh
    const hasHeader = Array.isArray(sheetDetail.header);
    const hasRows = Array.isArray(sheetDetail.rows);
    const hasValues = Array.isArray(sheetDetail.values);
    const hasHtmlData = Array.isArray(sheetDetail.htmlData);
    const hasHyperlinks = Array.isArray(sheetDetail.hyperlinks);
    
    console.log(`- header: ${hasHeader ? `‚úÖ (${sheetDetail.header?.length || 0} c·ªôt)` : '‚ùå'}`);
    console.log(`- rows: ${hasRows ? `‚úÖ (${sheetDetail.rows?.length || 0} h√†ng)` : '‚ùå'}`);
    console.log(`- values: ${hasValues ? `‚úÖ (${sheetDetail.values?.length || 0} h√†ng)` : '‚ùå'}`);
    console.log(`- htmlData: ${hasHtmlData ? `‚úÖ (${sheetDetail.htmlData?.length || 0} h√†ng)` : '‚ùå'}`);
    console.log(`- hyperlinks: ${hasHyperlinks ? `‚úÖ (${sheetDetail.hyperlinks?.length || 0} li√™n k·∫øt)` : '‚ùå'}`);
    
    // Ki·ªÉm tra c·∫•u tr√∫c rows n·∫øu c√≥
    if (hasRows && sheetDetail.rows.length > 0) {
      const sampleRow = sheetDetail.rows[0];
      console.log('- Sample row structure:', sampleRow);
      
      // Ki·ªÉm tra _hyperlinks
      if (sampleRow._hyperlinks) {
        console.log('- _hyperlinks found in rows:', sampleRow._hyperlinks);
      }
      
      // Ki·ªÉm tra processedData.urls
      if (sampleRow.processedData && Array.isArray(sampleRow.processedData.urls)) {
        console.log('- processedData.urls found:', sampleRow.processedData.urls);
      }
    }
    
    // Ki·ªÉm tra c·∫•u tr√∫c values n·∫øu c√≥
    if (hasValues && sheetDetail.values.length > 0) {
      console.log('- First row in values (header):', sheetDetail.values[0]);
      if (sheetDetail.values.length > 1) {
        console.log('- Second row in values (first data row):', sheetDetail.values[1]);
      }
    }
    
    // Ki·ªÉm tra c·∫•u tr√∫c htmlData chi ti·∫øt
    if (hasHtmlData && sheetDetail.htmlData.length > 0) {
      console.log('- Analyzing htmlData structure:');
      
      // L·∫•y m·∫´u m·ªôt s·ªë h√†ng
      const sampleRows = [0, 1, 2].filter(idx => idx < sheetDetail.htmlData.length);
      
      sampleRows.forEach(rowIdx => {
        const htmlRow = sheetDetail.htmlData[rowIdx];
        console.log(`  - Row ${rowIdx} type:`, Array.isArray(htmlRow) ? 'Array' : typeof htmlRow);
        
        // Ki·ªÉm tra c·∫•u tr√∫c c·ªßa h√†ng
        if (Array.isArray(htmlRow)) {
          // T√¨m c√°c √¥ c√≥ hyperlink
          const hyperlinks = [];
          htmlRow.forEach((cell, cellIdx) => {
            if (cell && cell.hyperlink) {
              hyperlinks.push({ cellIdx, hyperlink: cell.hyperlink });
            }
          });
          
          if (hyperlinks.length > 0) {
            console.log(`  - Row ${rowIdx} has ${hyperlinks.length} hyperlinks:`, hyperlinks);
          } else {
            console.log(`  - Row ${rowIdx} has no hyperlinks`);
          }
        } else if (htmlRow && htmlRow.values && Array.isArray(htmlRow.values)) {
          // T√¨m c√°c √¥ c√≥ hyperlink
          const hyperlinks = [];
          htmlRow.values.forEach((cell, cellIdx) => {
            if (cell && cell.hyperlink) {
              hyperlinks.push({ cellIdx, hyperlink: cell.hyperlink });
            }
          });
          
          if (hyperlinks.length > 0) {
            console.log(`  - Row ${rowIdx} has ${hyperlinks.length} hyperlinks:`, hyperlinks);
          } else {
            console.log(`  - Row ${rowIdx} has no hyperlinks`);
          }
        }
      });
      
      // ƒê·∫øm t·ªïng s·ªë hyperlink trong htmlData
      let totalHyperlinks = 0;
      sheetDetail.htmlData.forEach((row, rowIdx) => {
        if (Array.isArray(row)) {
          row.forEach(cell => {
            if (cell && cell.hyperlink) totalHyperlinks++;
          });
        } else if (row && row.values && Array.isArray(row.values)) {
          row.values.forEach(cell => {
            if (cell && cell.hyperlink) totalHyperlinks++;
          });
        }
      });
      
      console.log(`- Total hyperlinks found in htmlData: ${totalHyperlinks}`);
    }
    
    // Ki·ªÉm tra c·∫•u tr√∫c hyperlinks n·∫øu c√≥
    if (hasHyperlinks && sheetDetail.hyperlinks.length > 0) {
      console.log('- Sample hyperlinks:', sheetDetail.hyperlinks.slice(0, 3));
    }
    
    // Ki·ªÉm tra t·∫•t c·∫£ c√°c h√†ng ƒë·ªÉ t√¨m hyperlinks
    if (hasRows) {
      let rowsWithUrls = 0;
      let totalUrls = 0;
      
      sheetDetail.rows.forEach((row, index) => {
        if (row.processedData && Array.isArray(row.processedData.urls) && row.processedData.urls.length > 0) {
          rowsWithUrls++;
          totalUrls += row.processedData.urls.length;
          
          // Log chi ti·∫øt v·ªÅ 2 h√†ng ƒë·∫ßu ti√™n c√≥ URLs
          if (rowsWithUrls <= 2) {
            console.log(`- Row ${index} has ${row.processedData.urls.length} URLs:`, row.processedData.urls);
          }
        }
      });
      
      console.log(`- Found ${totalUrls} URLs in ${rowsWithUrls} rows`);
    }
  };

  // Render b·∫£ng d·ªØ li·ªáu
  const renderTable = (sheetDetail) => {
    if (!sheetDetail) {
      return <div>Kh√¥ng c√≥ d·ªØ li·ªáu</div>;
    }

    // Log to√†n b·ªô c·∫•u tr√∫c d·ªØ li·ªáu
    console.log('üéØ To√†n b·ªô d·ªØ li·ªáu sheet:', sheetDetail);
    console.log('Sheet Name:', sheetDetail.name || 'Kh√¥ng c√≥ t√™n trong d·ªØ li·ªáu chi ti·∫øt');
    
    // Debug c·∫•u tr√∫c d·ªØ li·ªáu
    debugSheetStructure(sheetDetail);

    // Ki·ªÉm tra c·∫•u tr√∫c d·ªØ li·ªáu v√† l·∫•y header/rows ph√π h·ª£p
    let header = [];
    let rows = [];

    // Tr∆∞·ªùng h·ª£p 1: C·∫•u tr√∫c m·ªõi v·ªõi header v√† rows
    if (Array.isArray(sheetDetail.header) && Array.isArray(sheetDetail.rows)) {
      header = sheetDetail.header;
      rows = sheetDetail.rows;
      console.log('S·ª≠ d·ª•ng c·∫•u tr√∫c d·ªØ li·ªáu m·ªõi v·ªõi header/rows');
    }
    // Tr∆∞·ªùng h·ª£p 2: D·ªØ li·ªáu t·ª´ API v·ªõi values
    else if (Array.isArray(sheetDetail.values) && sheetDetail.values.length > 0) {
      // L·∫•y header t·ª´ d√≤ng ƒë·∫ßu ti√™n c·ªßa values
      const headerRow = sheetDetail.values[0] || [];
      header = headerRow.map(item => String(item || '').trim());
      
      // Chuy·ªÉn ƒë·ªïi c√°c d√≤ng c√≤n l·∫°i th√†nh m·∫£ng c√°c object
      rows = sheetDetail.values.slice(1).map((row, rowIndex) => {
        const rowData = {};
        header.forEach((col, idx) => {
          if (col && idx < row.length) {
            rowData[col] = row[idx];
          }
        });

        // Th√™m _hyperlinks n·∫øu t√¨m th·∫•y
        rowData._hyperlinks = {};
        
        // Ki·ªÉm tra trong htmlData n·∫øu c√≥
        if (Array.isArray(sheetDetail.htmlData) && sheetDetail.htmlData.length > rowIndex + 1) {
          const htmlRow = sheetDetail.htmlData[rowIndex + 1]; // +1 v√¨ htmlData c√≥ th·ªÉ bao g·ªìm header
          
          if (htmlRow && Array.isArray(htmlRow)) {
            htmlRow.forEach((cell, cellIndex) => {
              if (cell && cell.hyperlink && cellIndex < header.length) {
                const columnName = header[cellIndex];
                if (columnName) {
                  // N·∫øu l√† hyperlink th·∫≠t t·ª´ htmlData, ∆∞u ti√™n s·ª≠ d·ª•ng
                  rowData._hyperlinks[columnName] = cell.hyperlink;
                  console.log(`S·ª≠ d·ª•ng hyperlink th·∫≠t t·ª´ htmlData cho [${rowIndex},${cellIndex}] (${columnName}):`, cell.hyperlink);
                }
              }
            });
          }
        }
        
        return rowData;
      });
      
      console.log('ƒê√£ chuy·ªÉn ƒë·ªïi t·ª´ c·∫•u tr√∫c values th√†nh header/rows');
    }
    // Kh√¥ng c√≥ d·ªØ li·ªáu h·ª£p l·ªá
    else {
      console.error('Kh√¥ng t√¨m th·∫•y c·∫•u tr√∫c d·ªØ li·ªáu h·ª£p l·ªá:', sheetDetail);
      return <div>Kh√¥ng t√¨m th·∫•y d·ªØ li·ªáu h·ª£p l·ªá</div>;
    }

    // Log th√¥ng tin v·ªÅ d·ªØ li·ªáu
    console.log('Header ƒë√£ x·ª≠ l√Ω:', header);
    console.log('S·ªë c·ªôt:', header.length);
    console.log('Rows ƒë√£ x·ª≠ l√Ω:', rows.length > 10 ? `${rows.length} h√†ng` : rows);
    console.log('T·ªïng s·ªë h√†ng:', rows.length);

    const sortedData = getSortedData(rows, header);

    return (
      <div className="overflow-x-auto">
        <table className="min-w-full divide-y divide-gray-200">
          <thead className="bg-gray-50">
            <tr>
              {header.map((column, index) => (
                <th
                  key={index}
                  scope="col"
                  className={`px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider cursor-pointer relative ${
                    sortConfig.key === index ? 'bg-gray-100' : ''
                  }`}
                  onClick={() => requestSort(index)}
                  onMouseEnter={() => setHoveredHeader(index)}
                  onMouseLeave={() => setHoveredHeader(null)}
                >
                  {column}
                  {hoveredHeader === index && (
                    <span className="absolute inset-y-0 right-0 flex items-center pr-2">
                      <ArrowPathIcon className="h-4 w-4 text-gray-400" aria-hidden="true" />
                    </span>
                  )}
                </th>
              ))}
            </tr>
          </thead>
          <tbody className="bg-white divide-y divide-gray-200">
            {sortedData.map((row, rowIndex) => (
              <tr key={rowIndex} className={rowIndex % 2 === 0 ? 'bg-white' : 'bg-gray-50'}>
                {header.map((column, cellIndex) => {
                  const cellContent = row[column];
                  const hyperlink = row._hyperlinks?.[column] || getHyperlinkFromValues(
                    rowIndex, 
                    cellIndex, 
                    sheetDetail.values, 
                    sheetDetail.htmlData,
                    sheetDetail.rows,
                    sheetDetail.header,
                    sheetDetail.hyperlinks
                  );
                  
                  // Log th√¥ng tin cell n·∫øu c√≥ hyperlink
                  if (hyperlink) {
                    console.log(`üîó Cell [${rowIndex},${cellIndex}]:`, {
                      column,
                      content: cellContent,
                      hyperlink
                    });
                  }
                  
                  return (
                    <td key={cellIndex} className="px-6 py-4 whitespace-nowrap text-sm text-gray-900">
                      {hyperlink ? (
                        renderHyperlinkCell(hyperlink, formatCellContent(cellContent, column) || '', rowIndex, cellIndex)
                      ) : (
                        <span>{formatCellContent(cellContent, column) || ''}</span>
                      )}
                    </td>
                  );
                })}
              </tr>
            ))}
          </tbody>
        </table>
      </div>
    );
  };

  // H√†m l·∫•y hyperlink t·ª´ values v√† htmlData
  const getHyperlinkFromValues = (rowIndex, cellIndex, values, htmlData, rows, header, hyperlinks) => {
    // Ki·ªÉm tra trong c·∫•u tr√∫c hyperlinks m·ªõi
    if (Array.isArray(hyperlinks)) {
      const hyperlink = hyperlinks.find(link => link.row === rowIndex && link.col === cellIndex);
      if (hyperlink) {
        console.log(`T√¨m th·∫•y hyperlink trong hyperlinks [${rowIndex},${cellIndex}]:`, hyperlink.url);
        return hyperlink.url;
      }
    }
    
    // Ki·ªÉm tra trong rows v·ªõi _hyperlinks
    if (Array.isArray(rows) && rowIndex < rows.length && Array.isArray(header) && cellIndex < header.length) {
      const row = rows[rowIndex];
      const columnName = header[cellIndex];
      
      if (row && row._hyperlinks && columnName && row._hyperlinks[columnName]) {
        console.log(`T√¨m th·∫•y hyperlink trong rows._hyperlinks [${rowIndex},${cellIndex}]:`, row._hyperlinks[columnName]);
        return row._hyperlinks[columnName];
      }
      
      // Ki·ªÉm tra trong processedData.urls n·∫øu c√≥
      if (row && row.processedData && Array.isArray(row.processedData.urls)) {
        const urlData = row.processedData.urls.find(url => url.colIndex === cellIndex);
        if (urlData && urlData.url) {
          console.log(`T√¨m th·∫•y hyperlink trong processedData.urls [${rowIndex},${cellIndex}]:`, urlData.url);
          return urlData.url;
        }
      }
    }
    
    // Ki·ªÉm tra trong values
    if (Array.isArray(values) && values.length > rowIndex + 1) {
      // +1 v√¨ d√≤ng ƒë·∫ßu ti√™n l√† header
      const row = values[rowIndex + 1];
      if (row && row.length > cellIndex) {
        const cellValue = row[cellIndex];
        
        // Ki·ªÉm tra n·∫øu cell c√≥ d·∫°ng URL
        if (typeof cellValue === 'string' && (
          cellValue.startsWith('http') || 
          cellValue.startsWith('www.') ||
          cellValue.includes('youtube.com') ||
          cellValue.includes('youtu.be') ||
          cellValue.includes('drive.google.com')
        )) {
          console.log(`T√¨m th·∫•y hyperlink trong values [${rowIndex},${cellIndex}]:`, cellValue);
          return cellValue;
        }
      }
    }
    
    // Ki·ªÉm tra trong htmlData n·∫øu c√≥
    if (Array.isArray(htmlData)) {
      // Ki·ªÉm tra c·∫£ hai c·∫•u tr√∫c c√≥ th·ªÉ c√≥ c·ªßa htmlData
      
      // C·∫•u tr√∫c 1: htmlData l√† m·∫£ng c√°c m·∫£ng
      if (htmlData.length > rowIndex + 1) {  // +1 v√¨ c√≥ th·ªÉ bao g·ªìm header
        const htmlRow = htmlData[rowIndex + 1];
        
        // Ki·ªÉm tra n·∫øu htmlRow l√† m·∫£ng tr·ª±c ti·∫øp
        if (Array.isArray(htmlRow) && htmlRow.length > cellIndex) {
          const htmlCell = htmlRow[cellIndex];
          if (htmlCell && htmlCell.hyperlink) {
            console.log(`T√¨m th·∫•y hyperlink trong htmlData (array) [${rowIndex},${cellIndex}]:`, htmlCell.hyperlink);
            return htmlCell.hyperlink;
          }
        }
        // Ki·ªÉm tra n·∫øu htmlRow c√≥ c·∫•u tr√∫c {values: [...]}
        else if (htmlRow && htmlRow.values && Array.isArray(htmlRow.values) && htmlRow.values.length > cellIndex) {
          const htmlCell = htmlRow.values[cellIndex];
          if (htmlCell && htmlCell.hyperlink) {
            console.log(`T√¨m th·∫•y hyperlink trong htmlData.values [${rowIndex},${cellIndex}]:`, htmlCell.hyperlink);
            return htmlCell.hyperlink;
          }
        }
      }
    }
    
    // Tr√≠ch xu·∫•t URL t·ª´ n·ªôi dung cell (n·∫øu c√≥)
    if (Array.isArray(values) && values.length > rowIndex + 1) {
      const row = values[rowIndex + 1];
      if (row && row.length > cellIndex) {
        const cellValue = row[cellIndex];
        
        // N·∫øu c√≥ n·ªôi dung, th·ª≠ tr√≠ch xu·∫•t URL ho·∫∑c YouTube ID
        if (cellValue) {
          // Ki·ªÉm tra n·∫øu l√† c·ªôt CH∆Ø∆†NG v√† c√≥ th·ªÉ l√† ID video
          const columnName = header?.[cellIndex];
          if (columnName === "CH∆Ø∆†NG") {
            console.log(`Ki·ªÉm tra cell [${rowIndex},${cellIndex}] (${columnName}): "${cellValue}"`);
            
            // N·∫øu l√† s·ªë v√† c√≥ ƒë·ªô d√†i 11 k√Ω t·ª± (c√≥ th·ªÉ l√† YouTube ID)
            if (typeof cellValue === 'string' && /^\d+$/.test(cellValue) && cellValue.length === 11) {
              const youtubeUrl = `https://www.youtube.com/watch?v=${cellValue}`;
              console.log(`Ph√°t hi·ªán c√≥ th·ªÉ l√† YouTube ID trong CH∆Ø∆†NG: ${cellValue} -> ${youtubeUrl}`);
              return youtubeUrl;
            }
            
            // Th·ª≠ tr√≠ch xu·∫•t URL t·ª´ n·ªôi dung
            const extractedUrl = extractRealUrl(cellValue);
            if (extractedUrl) {
              console.log(`Tr√≠ch xu·∫•t ƒë∆∞·ª£c URL t·ª´ c·ªôt CH∆Ø∆†NG: ${extractedUrl}`);
              return extractedUrl;
            }
          }
        }
      }
    }
    
    return null;
  };

  // H√†m x·ª≠ l√Ω sheet l√™n database
  const handleProcessSheet = async () => {
    if (!apiSheetData || !apiSheetData.sheets || apiSheetData.sheets.length === 0) {
      return;
    }

    const currentSheet = apiSheetData.sheets[activeApiSheet];
    if (!currentSheet) return;

    setProcessingSheet(true);
    try {
      await processSheetToDb(currentSheet._id);
      console.log('‚úÖ ƒê√£ x·ª≠ l√Ω sheet th√†nh c√¥ng');
    } catch (error) {
      console.error('‚ùå L·ªói khi x·ª≠ l√Ω sheet:', error);
    } finally {
      setProcessingSheet(false);
    }
  };

  // H√†m s·ª≠a l·ªói hyperlink
  const handleFixHyperlinks = async () => {
    if (!apiSheetData?.sheets || !apiSheetData.sheets[activeApiSheet]) return;
    
    const currentSheet = apiSheetData.sheets[activeApiSheet];
    setProcessingSheet(true);
    
    try {
      // G·ªçi API x·ª≠ l√Ω sheet v·ªõi t√πy ch·ªçn ƒë·∫∑c bi·ªát ƒë·ªÉ s·ª≠a hyperlink
      const response = await fetch(`/api/sheets/${currentSheet._id}/process-to-db`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({ 
          background: false,
          preserveHyperlinks: true,
          includeHtmlData: true,
          fixHyperlinks: true,  // T√πy ch·ªçn ƒë·∫∑c bi·ªát ƒë·ªÉ s·ª≠a hyperlink
          forceReprocess: true  // B·∫Øt bu·ªôc x·ª≠ l√Ω l·∫°i
        })
      });
      
      if (!response.ok) {
        throw new Error(`L·ªói ${response.status}: ${response.statusText}`);
      }
      
      const result = await response.json();
      console.log('K·∫øt qu·∫£ s·ª≠a hyperlink:', result);
      
      // Sau khi x·ª≠ l√Ω th√†nh c√¥ng, t·∫£i l·∫°i d·ªØ li·ªáu sheet
      await fetchSheetDetail(currentSheet._id);
      
      alert('ƒê√£ s·ª≠a l·ªói hyperlink th√†nh c√¥ng!');
    } catch (error) {
      console.error('L·ªói khi s·ª≠a hyperlink:', error);
      alert(`L·ªói khi s·ª≠a hyperlink: ${error.message}`);
    } finally {
      setProcessingSheet(false);
    }
  };

  return (
    <div className="bg-white shadow rounded-lg overflow-hidden">
      {/* Sheet selector */}
      {apiSheetData?.sheets && apiSheetData.sheets.length > 0 && (
        <div className="border-b border-gray-200">
          <div className="px-4 sm:px-6 py-4">
        <div className="flex flex-wrap gap-2">
            {apiSheetData.sheets.map((sheet, index) => (
              <button
                  key={sheet._id}
                onClick={() => setActiveApiSheet(index)}
                  className={`px-4 py-2 text-sm font-medium rounded-md transition-colors duration-200 ${
                    index === activeApiSheet
                      ? 'bg-indigo-600 text-white'
                      : 'bg-gray-100 text-gray-700 hover:bg-gray-200'
                  }`}
                >
                  {sheet.name || `Sheet ${index + 1}`}
              </button>
            ))}
            </div>
          </div>
        </div>
      )}

      {/* Sheet content */}
      <div className="px-4 sm:px-6 py-4">
        {loadingApiSheet ? (
          <div className="flex justify-center items-center py-8">
            <div className="inline-block animate-spin rounded-full h-8 w-8 border-t-2 border-b-2 border-indigo-600 mb-2 mr-3"></div>
            <p className="text-gray-600">ƒêang t·∫£i d·ªØ li·ªáu sheet...</p>
          </div>
        ) : apiSheetError ? (
          <div className="bg-red-50 p-4 rounded-md">
            <p className="text-red-700 font-medium mb-2">L·ªói khi t·∫£i d·ªØ li·ªáu</p>
            <p className="text-red-600 mb-4">{apiSheetError}</p>
            <button 
              onClick={() => fetchApiSheetData()}
              className="inline-flex items-center px-3 py-2 border border-transparent text-sm leading-4 font-medium rounded-md text-white bg-red-600 hover:bg-red-700"
            >
              <svg className="h-4 w-4 mr-1" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
              </svg>
              Th·ª≠ l·∫°i
            </button>
                  </div>
        ) : (
          <>
            {/* Sheet data */}
            {apiSheetData?.sheets && apiSheetData.sheets[activeApiSheet]?.detail ? (
              <>
                {/* Sheet title and actions */}
                <div className="flex justify-between items-center mb-4">
                  <h3 className="text-lg font-medium text-gray-900">
                    {apiSheetData.sheets[activeApiSheet].name || apiSheetData.sheets[activeApiSheet].detail?.name || `Sheet ${activeApiSheet + 1}`}
                  </h3>
                  <div className="flex space-x-2">
                    <button 
                      onClick={() => fetchSheetDetail(apiSheetData.sheets[activeApiSheet]._id)}
                      className="inline-flex items-center px-3 py-2 border border-transparent text-sm leading-4 font-medium rounded-md text-white bg-indigo-600 hover:bg-indigo-700"
                    >
                      <svg className="h-4 w-4 mr-1" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
                      </svg>
                      L√†m m·ªõi
                    </button>
                  </div>
                </div>

                {/* Sheet data table */}
                {renderTable(apiSheetData.sheets[activeApiSheet].detail)}

                {/* Modals */}
                {selectedVideo && (
                  <YouTubeModal
                    isOpen={true}
                    videoId={selectedVideo}
                    onClose={() => setSelectedVideo(null)}
                  />
                )}
                {selectedPlaylist && (
                  <YouTubePlaylistModal
                    isOpen={true}
                    playlistId={selectedPlaylist}
                    videoId={selectedPlaylistVideo}
                    onClose={() => {
                      setSelectedPlaylist(null);
                      setSelectedPlaylistVideo(null);
                    }}
                    title="Danh s√°ch ph√°t YouTube"
                  />
                )}
                {selectedPDF && (
                  <PDFModal
                    isOpen={true}
                    url={selectedPDF}
                    title={pdfTitle}
                    onClose={() => setSelectedPDF(null)}
                  />
                )}
              </>
            ) : (
              <div className="text-center py-8 text-gray-500">
                Kh√¥ng c√≥ d·ªØ li·ªáu ƒë·ªÉ hi·ªÉn th·ªã
              </div>
            )}
          </>
        )}
      </div>
    </div>
  );
} 